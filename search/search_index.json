{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Still.js Framework","text":"Still.js is a modern frontend framework that enables developers to write and reuse Vanilla JavaScript while providing a modular and component-based architecture similar to React, Angular, and VueJS. It offers a lightweight yet powerful approach to structuring applications, allowing for better maintainability and scalability without introducing a complex abstraction layer. With StillJS, you get the flexibility of raw JavaScript while benefiting from an organized and efficient development workflow.     <p>     A limitted set of resources a features are provided by still.js, yet those resources offer a complete and transversall capabilities for building Web Applications frontend from the very simple ones, to the most complex ones, follo the list of features in summary:     </p> Component Base UI,         HTML Base template,         Built-in notations/directives,         User permission flow,         Component State Management,         Global state management ,         Routing ,         Form validation ,         Web component ,         Built-in annotations"},{"location":"#microfrontend-disruptivelly","title":"Microfrontend Disruptivelly","text":"<p>One particular aspect of Still.js is the capabilities it provides to create microfronted in a disruptive way, means, we can embed Still.js component in our existing application, but, such component can be a whole front end providing access to all kind of features including navigation.</p>"},{"location":"#annotation-based","title":"Annotation Based","text":"<p>Still.js is built entirely on vanilla JavaScript, no builder or bundler are used. It introduces a unique approach to annotations by leveraging JSDoc and JavaScript comments, not for documentation but to dynamically add features at runtime.</p>"},{"location":"#typing","title":"Typing","text":"<p>Still.js uses JSDoc for typing and type hinting, enabling most TypeScript features. However, typing is generally optional, except in specific cases where it's required.</p>"},{"location":"#scv-architecture","title":"SCV Architecture","text":"<p>Still.js follow it's own architecture approach named Service, Controller and View which has its own specificities, follow the representation diagram:</p> <p></p> <p>The above components can be summarized as follow:</p> <ul> <li>Service - Serves/Provide data to the View, takes care of transactions like HTTP requests</li> <li>Controller - Serves the view with different behavior and DOM implementation</li> <li>View - Display whatever needs to be showed to the used</li> </ul> <p>Click here for more details about the Architecture of Still.js</p> <p></p>"},{"location":"#join-the-discord-channel","title":"Join the discord channel","text":"<p>  Still.js on discord </p>"},{"location":"annotation/","title":"COMPONENT ANNOTATIONS","text":""},{"location":"annotation/#overview","title":"Overview","text":"<p>Since Still.js is built with vanilla JavaScript, which doesn't support annotations, it uses JavaScript comments and JSDoc to enable annotation-like capabilities. Still.js defines its own specific annotation format for this purpose.</p> <p>Still.js currently supports 5 annotations, 4 of which are top-level and must appear at the top. These annotations are used for specific scenarios, allowing components to have metadata available at runtime.</p>"},{"location":"annotation/#still-command-line-tool","title":"Still Command Line Tool","text":"<p>Changes @Path from @ServicePath</p> <p>If you're using Still.js version &lt;=0.0.17 the <code>@ServicePath</code> annotation is named <code>@Path</code>.</p> <p></p> <p></p> Annotation Required complement Description Use context @Proptop-level N/A Annotates a component variables to specify that it'll be a property and not a state. <ul> <li>Component variable which does not need reactive behavior</li> <li>Component flags (e.g. assign true/false)</li> <li>Internal component business logic flow</li> </ul> @Proxytop-level N/A Define a class property which serve as a link between Parent and a child component (embeded). JSDoc @type can complement providing type hinting. <ul> <li>Provide parent with public child methods and property/states</li> <li>Parent-to-child communication</li> </ul> @Injecttop-level JSDoc @type Define a class property which serve as a link between Parent and a child component (embeded) <ul> <li>Inject the defined type (@type) as dependency</li> </ul> @Controllertop-level JSDoc @type Alternative to @Inject which in addition to injection adds the specified controller as the main controller of the component allowing it to be referenced as controller. in the template <ul> <li>Inject the defined type (@type) as dependency</li> </ul> @Path N/A Complementary to the @Inject or @Controller annotation and recieves the path of the service being injected. If used it needs to come right after @Inject or @Controller annotation <ul> <li>Specify the folder path where the service/controller is located</li> </ul> <p></p> <p></p>"},{"location":"annotation/#examples-setup","title":"Examples Setup","text":"<p>The examples in this documentation/tutorials will be base in the bellow folder structure, Application Setup (<code>app-setup.js</code>) and routes metadata (<code>route.map.js</code>)</p>  Project folder structureapp-setup.jsroute.map.js Project folder structure<pre><code>project-root-folder\n|__ @still/\n|__ app/\n|   |\n|   |__ base-components/\n|   |   |__ HomeComponent.js\n|   |   |\n|   |__ person/\n|   |   |__ PersonForm.js\n|   |   |__ PersonList.js\n|   |   |\n|   |__ services/\n|   |   |__ MainService.js\n|   |   |__ user/\n|   |   |   |__ UserService.js\n|   |   |   |\n|__ config/\n|    |__ app-setup.js\n|    |__ route.map.js\n|__  ...\n</code></pre> This files stays in the project root folder<pre><code>import { StillAppMixin } from \"./@still/component/super/AppMixin.js\";\nimport { Components } from \"./@still/setup/components.js\";\nimport { AppTemplate } from \"./app-template.js\";\nimport { HomeComponent } from \"./app/base-components/HomeComponent.js\";\n\nexport class StillAppSetup extends StillAppMixin(Components) {\n\n    constructor() {\n        super();\n        // This is the service path setup\n        this.setServicePath('services/')\n        this.setHomeComponent(HomeComponent);\n    }\n\n    async init() {\n        return await AppTemplate.newApp();\n    }\n\n}\n</code></pre> This is the where Application context aspects are setup. This file is in the root folder.<pre><code>export const stillRoutesMap = {\n    viewRoutes: {\n        regular: {\n            HomeComponent: {\n                path: \"app/base-components\",\n                url: \"/home\"\n            },\n            PersonForm: {\n                path: \"app/person\",\n                url: \"/person/register\"\n            },\n            PersonList: {\n                path: \"app/person\",\n                url: \"/person/register\"\n            }\n        },\n        lazyInitial: {}\n    }\n}\n</code></pre> <p> </p>"},{"location":"annotation/#prop-defining-component-property-variable","title":"@Prop - Defining component property variable","text":"<p>This example takes into consideration the above folder structure, app and routing setup.</p> <p>By default, variables in a Still.js component are reactive state variables unless it's a special one like <code>isPublic</code>, <code>template</code>, <code>$parent</code>, etc. If reactivity isn't needed, it's recommended to use the <code>@Prop</code> annotation to define a non-reactive variable instead. </p> HomeComponent.js This component is placed in the app/base-components/ folder<pre><code>import { ViewComponent } from \"../../@still/component/super/ViewComponent.js\";\n\nexport class HomeComponent extends ViewComponent {\n\n    isPublic = true;\n\n    /** @Prop */\n    retryConnectionCount = 0;\n\n    /** @Prop */ isUserAdmin = true;\n\n    /** @Prop */\n    showDate = false;\n\n    template = `\n        &lt;div&gt;\n            &lt;!-- Property binding does not get reflected is changed --&gt;\n            &lt;p&gt;Binding User admin flag: @isUserAdmin&lt;/p&gt;\n            &lt;button (click)=\"changeProp()\"&gt;Update prop&lt;/button&gt;\n        &lt;/div&gt;\n    `;\n\n    changeProp() {\n        //This property is bound in line 18\n        this.isUserAdmin = false;\n        this.printPropNewValue();\n    }\n\n    printPropNewValue() {\n        console.log(`New User Admin flag is: `, this.isUserAdmin);\n    }\n}\n</code></pre> <p>Annotations can be defined in the same line as the variable like in line 10 of previous example. <code>Prop</code> variables can also be bound (line 18) just as <code>State</code> variables, but changes to it won't reflect to binding.</p> <p>Although <code>Prop</code> does not reactively reflect to binding, it natually have the expected reflection in the component internal flow (e.g. line 30) thereby totally suitable to be used in any business logic.</p> <p></p>"},{"location":"annotation/#prop-special-case-of-reactive-effect","title":"@Prop Special case of Reactive effect","text":"<p>This example takes into consideration the above folder structure, app and routing setup.</p> <p><code>Prop</code> variables are made not to behave reactively, however, when combined with <code>(showIf)</code> directive it will act reactively against it, follow the example with animated result right after:</p> HomeComponent.js This component is placed in the app/base-components/ folder<pre><code>import { ViewComponent } from \"../../@still/component/super/ViewComponent.js\";\n\nexport class HomeComponent extends ViewComponent {\n\n    isPublic = true;\n\n    /** @Prop */ date = new Date().toLocaleDateString();\n\n    /** @Prop */ showDate = false;\n\n    template = `\n        &lt;div&gt;\n            &lt;p&gt;Press the button to show the date&lt;/p&gt;\n            &lt;!-- Binding a boolean property to (showIf) directive --&gt;\n            &lt;p (showIf)=\"self.showDate\"&gt;Today's date is &lt;b&gt;@date&lt;/b&gt;&lt;/p&gt;\n            &lt;button \n                (click)=\"showTheDate()\"\n            &gt;Show Date&lt;/button&gt;\n        &lt;/div&gt;\n    `;\n\n    showTheDate() {\n        this.showDate = !this.showDate;\n    }\n\n}\n</code></pre> <p>Animated result:</p> <p></p> <p> </p>"},{"location":"annotation/#using-proxy-for-parent-to-child-components-communication","title":"Using @Proxy for Parent to child components communication","text":"<p>This example takes into consideration the above folder structure, app and routing setup.</p> <p>This is an approach provided in Still.js that enables parent-to-child components communication, in this case, parent needs to define a <code>@Proxy</code> for every single child, this needs to be referenced in <code>&lt;st-element proxy=\"myProxyVar\"&gt;</code> tag. It's also nice to have the <code>@type</code> definition as it'll help with development experience in the intelicesnse and type hinting.</p> <p>Bellow is a code sample with the animated result right after it:</p> HomeComponent.jsPersonForm.jsPersonList.js This component is placed in the app/base-components/ folder<pre><code>import { ViewComponent } from \"../../@still/component/super/ViewComponent.js\";\nimport { PersonForm } from \"../person/PersonForm.js\";\nimport { PersonList } from \"../person/PersonList.js\";\n\nexport class HomeComponent extends ViewComponent {\n\n    isPublic = true;\n\n    /** @Proxy @type { PersonForm } */\n    personFormProxy;\n\n    /** @Proxy @type { PersonList } */\n    listPersonProxy;\n\n    template = `\n        &lt;div&gt;\n            &lt;p&gt;Handle Person form from bellow buttons&lt;/p&gt;\n            &lt;button (click)=\"changePersonText()\"&gt;Change Person&lt;/button&gt;\n            &lt;button (click)=\"callFromChild()\"&gt;Call the Person&lt;/button&gt;\n            &lt;button (click)=\"showMoreInList()\"&gt;Handle Person List&lt;/button&gt;\n            &lt;p&gt;-&lt;/p&gt;\n        &lt;/div&gt;\n\n        &lt;st-element \n            component=\"PersonForm\"\n            proxy=\"personFormProxy\"\n        &gt;&lt;/st-element&gt;\n\n        &lt;st-element \n            component=\"PersonList\"\n            proxy=\"listPersonProxy\"\n        &gt;&lt;/st-element&gt;\n    `;\n\n    changePersonText() {\n        //This will update a state variable of the embeded component (PersonForm)\n        this.personFormProxy.myText = `&lt;b style=\"color:red;\"&gt;Parent assigned value&lt;/b&gt;`;\n    }\n\n    callFromChild() {\n        //doSomething is child component method, and called througg the proxy\n        this.personFormProxy.doSomething();\n    }\n\n    showMoreInList() {\n        this.listPersonProxy.showMore = !this.listPersonProxy.showMore;\n    }\n}\n</code></pre> This component is placed in the app/person/ folder<pre><code>import { ViewComponent } from \"../../@still/component/super/ViewComponent.js\";\n\nexport class PersonForm extends ViewComponent {\n\n    isPublic = true;\n\n    //This is a state which reactively \n    //updates in case its value gets changed\n    //And parent component will be changing it\n    myText = 'Initial value';\n\n    template = `\n        &lt;div&gt;\n            &lt;p&gt;I'm ParsonForm. My state is bound and will be updated by parent&lt;/p&gt;\n            &lt;p&gt;@myText&lt;/p&gt;\n        &lt;/div&gt;\n        &lt;hr/&gt;&lt;br/&gt;\n    `;\n\n    doSomething() {\n        this.myText = `&lt;b style=\"color:green;\"&gt;New value from the method&lt;/b&gt;`;\n    }\n}\n</code></pre> This component is placed in the app/person/ folder<pre><code>import { ViewComponent } from \"../../@still/component/super/ViewComponent.js\";\n\nexport class PersonList extends ViewComponent {\n\n    isPublic = true;\n    //Parent component is changing this Prop value\n    /** @Prop */ showMore = false;\n\n    template = `\n        &lt;div&gt;\n            &lt;p&gt;\n                I have additional content.\n                &lt;div (showIf)=\"self.showMore\"&gt;\n                    This is Person more content\n                &lt;/div&gt;\n            &lt;/p&gt;\n        &lt;/div&gt;\n    `;\n\n}\n</code></pre> <p>Animated result</p> <p></p> <p> </p> <p></p>"},{"location":"annotation/#inject-use-services-for-global-store-and-http-services","title":"@Inject - Use Services for Global store and HTTP services","text":"<p>This example takes into consideration the above folder structure, app and routing setup.</p> <p>It allows Service dependency injection offering a centralized way to handle data processing and bsiness logic. Services also provide Global Storage and are ideal for implementing HTTP calls.</p> <p>Still.js uses a setter method at the application level (e.g., in <code>app-setup.js</code>) to define the folder for services. If services are located elsewhere, the <code>@Path</code> annotation can be used to speficy it in the example after this one. </p> HomeComponent.jsPersonList.jsMainService.js This component is placed in the app/base-components/ folder<pre><code>import { ViewComponent } from \"../../@still/component/super/ViewComponent.js\";\nimport { MainService } from \"../services/MainService.js\";\n\nexport class HomeComponent extends ViewComponent {\n\n    isPublic = true;\n\n    /** \n     * @Inject\n     * @type { MainService } \n     * */\n    serviceObj;\n\n    template = `\n        &lt;div&gt;\n            &lt;p&gt;Bellow Person List is being embeded&lt;/p&gt;\n            &lt;!-- ParsonList also injects the MainService --&gt;\n            &lt;st-element component=\"PersonList\"&gt;&lt;/st-element&gt;\n        &lt;/div&gt;\n    `;\n\n    stAfterInit() {\n        //Register to the service onLoad hook\n        this.serviceObj.on('load', async () =&gt; {\n            // Assigning the API response to the Store\n            const todos = await this.serviceObj.getTodos();\n            // Update the todos Store with API response\n            this.serviceObj.storeTodos(todos);\n        });\n    }\n\n}\n</code></pre> This component is placed in the app/person/ folder<pre><code>import { ViewComponent } from \"../../@still/component/super/ViewComponent.js\";\nimport { MainService } from \"../services/MainService.js\";\n\nexport class PersonList extends ViewComponent {\n\n    isPublic = true;\n\n    //This state will be updated with API response\n    top2List = null;\n\n    /** @Inject @type { MainService } */ servc;\n\n    template = `\n        &lt;div&gt;\n            &lt;p&gt;\n                &lt;br&gt;\n                &lt;b&gt;The top 5 tasks are:&lt;/b&gt;\n                &lt;hr&gt;\n                &lt;div&gt;@top2List&lt;/div&gt;\n            &lt;/p&gt;\n        &lt;/div&gt;\n    `;\n\n    stAfterInit() {\n        //Register to the service OnLoad hook\n        this.servc.on('load', () =&gt; {\n            //Assigning data from API, since this data is set by parent\n            //component, it might be available once child gets rendered\n            const apiResponse = this.servc.todosStore.value.slice(0, 5);\n\n            let result = '';\n            for (const user of apiResponse) {\n                result += '&lt;p&gt;' + JSON.stringify(user) + '&lt;/p&gt;';\n            }\n\n            this.top2List = result;\n\n            this.servc.todosStore.onChange((newResult) =&gt; {\n                //This will update the state in whenever service todosStore\n                //gets upated from anywhere\n                this.top2List = newResult;\n            });\n        });\n    }\n\n}\n</code></pre> This service is placed in the app/services/ folder<pre><code>import { $still } from \"../../@still/component/manager/registror.js\";\nimport { BaseService, ServiceEvent } from \"../../@still/component/super/service/BaseService.js\";\n\nexport class MainService extends BaseService {\n\n    // This store is being accessed in the PersonList\n    todosStore = new ServiceEvent([]);\n\n    // get todos from online Fake API, Called in the HomeComponent\n    async getTodos() {\n        const result = await $still\n            .HTTPClient\n            .get('https://jsonplaceholder.typicode.com/todos');\n        return result;\n    }\n\n    // Set new todos to the store. Called in the HomeComponent\n    storeTodos(todos) {\n        this.todosStore = todos;\n    }\n}\n</code></pre> <p>Result picture:</p> <p></p> <p></p>"},{"location":"annotation/#controller-sharing-ui-feature-between-components","title":"@Controller - Sharing UI feature between components","text":"<p>Just like the <code>@Inject</code>, the <code>@Controller</code> annotation allow to inject a controller to a component where a special situation as well as a constraint takes place as follow:</p> <ul> <li> <p>Special case: The controller annotated with <code>@Controller</code> is marked as the main controller of the component, which can be referenced in the template for HTML event binding using <code>controller.methodName()</code>.</p> </li> <li> <p>Contraint: Only one controller can be annotate with <code>@Controller</code>, if more than one, the last one will take precedence. In contrast <code>@Inject</code> can be used more than one.</p> </li> </ul> <p></p> <p>Example: The controller<pre><code>//The controller\nexport class NameOfController extends BaseController {\n    getInputValue(){\n        const value = document.getElementById('inputId').value;\n        return value;\n    }\n}\n</code></pre></p> Injection in the component<pre><code>/**\n * @Controller\n * @Path path-to/controller-folder/\n * @type { NameOfController }\n */\n mainController;\n</code></pre> Referencing in the component template<pre><code>&lt;div&gt;\n    &lt;form&gt;\n        &lt;input type=\"text\" id=\"inputId\"&gt;\n        &lt;button onclick=\"controller.getInputValue()\"&gt;Get Value&lt;/button&gt;\n    &lt;/form&gt;\n&lt;/div&gt;\n</code></pre> Referencing in anoter component template which didn't annotate with @Controller, or didn't inject at all<pre><code>&lt;!-- This should be a child or adjacent component --&gt;\n&lt;div&gt;\n    &lt;button onclick=\"controller('NameOfController').getInputValue()\"&gt;Get Value&lt;/button&gt;\n&lt;/div&gt;\n</code></pre> <p>Controllers are a way for components to share features whereas the Services are for Data sharing, therefore, the use case for it is for when we have a component which can have different child or sibling, but, only the main component should inject as <code>@Controller</code>, other components will inject it normally or only reference in the template.</p> <p> </p>"},{"location":"annotation/#path-specifying-service-path-when-injecting","title":"@Path - Specifying service path when @Injecting","text":"<p>This example takes into consideration the above folder structure, app and routing setup.</p> <p><code>@Path</code> is a second level annotation that might to come hence that have to come right after @Inject. It recieves the path to the folder where the service is located. Follow the code sample with the animated result:</p> HomeComponent.jsPersonList.jsUserService.js This component is placed in the app/base-components/ folder<pre><code>import { ViewComponent } from \"../../@still/component/super/ViewComponent.js\";\nimport { UserService } from \"../services/user/UserService.js\";\n\nexport class HomeComponent extends ViewComponent {\n\n    isPublic = true;\n\n    /** \n     * @Inject\n     * @Path services/user/\n     * @type { UserService } \n     * */\n    serviceObj;\n\n    //This prop is bound to the form input (line 21)\n    searchParam;\n\n    template = `\n        &lt;div style=\"padding: 10px;\"&gt;\n            &lt;form onsubmit=\"return false;\"&gt;\n                &lt;input (value)=\"searchParam\" placeholder=\"Type the user ID\"&gt;\n                &lt;button (click)=\"searchUser()\"&gt;Search&lt;/button&gt;\n            &lt;/form&gt;\n            &lt;st-element component=\"PersonList\"&gt;&lt;/st-element&gt;\n        &lt;/div&gt;\n    `;\n\n    async searchUser() {\n        const userId = this.searchParam.value;\n        const user = await this.serviceObj.getUserById(userId);\n        console.log(user);\n    }\n}\n</code></pre> This component is placed in the app/person/ folder<pre><code>import { ViewComponent } from \"../../@still/component/super/ViewComponent.js\";\nimport { UserService } from \"../services/user/UserService.js\";\n\nexport class PersonList extends ViewComponent {\n\n    isPublic = true;\n\n    //This state will be updated with API response\n    foundUser;\n\n    /** @Inject @type { UserService } */ servc;\n\n    template = `\n        &lt;div&gt;\n            &lt;p&gt;\n                &lt;br&gt;\n                &lt;b&gt;Search result is:&lt;/b&gt;\n                &lt;hr&gt;\n                &lt;div&gt;@foundUser&lt;/div&gt;\n            &lt;/p&gt;\n        &lt;/div&gt;\n    `;\n\n    stAfterInit() {\n        this.servc.on('load', () =&gt; {\n            this.servc.userSearchResult.onChange((newResult) =&gt; {\n                //This will update the state in whenever service todosStore\n                //gets upated from anywhere (e.g. parent component)\n                this.foundUser = newResult;\n            });\n        });\n    }\n\n}\n</code></pre> This service is placed in the app/services/user/ folder<pre><code>import { $still } from \"../../../@still/component/manager/registror.js\";\nimport { BaseService, ServiceEvent } from \"../../../@still/component/super/service/BaseService.js\";\n\nexport class UserService extends BaseService {\n\n    userSearchResult = new ServiceEvent();\n\n    // This is being called by the HomeComponent, and\n    // because the store gets updated, PersonLis get nofitied\n    async getUserById(userId) {\n        const url = 'https://jsonplaceholder.typicode.com/users/' + userId;\n        const user = await $still.HTTPClient.get(url);\n        this.userSearchResult = `Name: ${user.name} - email: ${user.email}`;\n    }\n}\n</code></pre> <p>Animated Result:</p> <p></p> <p> </p>"},{"location":"app-template/","title":"APP TEMPLATE","text":""},{"location":"app-template/#overview","title":"Overview","text":"<p>App template is the skeleton where the high level/base layout divisions are set/defined. When it comes to layout, it's common to have it dividide into parts like  \"Navigation Bar\", \"Top Menu\", \"Main Section\", \"Header\", \"Footer\", etc. Those definitions are easily managed by adding on the App Template.</p> <p>The default App Template includes a single <code>&lt;still-component&gt;</code> tag, which renders the active component based on routing or first component Loading set in the StillAppSetup. It must appear only once and is required in <code>app-template.js</code>. To add persistent UI parts, use <code>&lt;st-fixed&gt;</code> with a <code>component</code> property\u2014these remain visible across navigations.</p> <p>Lone component considerations</p> <p>Because AppTemplate is tied to the Still Application container, it's not available when using Lone component becuase in therms of rendering they are totally depending on the environment in which they being embeded.</p> <p></p>"},{"location":"app-template/#standard-apptemplate-app-templatejs-after-initiating-a-project","title":"Standard AppTemplate (<code>app-template.js</code>) after initiating a project","text":"app-setup.js This is the where Application context aspects are setup. This file is in the root folder.<pre><code>import { Template } from \"./@still/component/super/Template.js\";\n\nexport class AppTemplate extends Template {\n\n    /**\n     * &lt;still-component&gt; is the placeholder where components \n     * should be render both when loading or routing to the component\n     * \n     * &lt;still-fixed&gt; is the specification of a specific component part from the \n     * User interface that needs to be fiexed (e.g. Header, Footer, Menu, Navigation, etc.)\n     * \n     * THIS SHOULD BE CHANGED ACCORDING TO MY LAYOUT WHERE I'M HAVING COMPONENTS FOR\n     * EACH PART AND THE FIXED ONES WIIL BE REFERENCED AS &lt;st-fixed&gt; AND THE COMPONENT\n     * TO BE RENDERED WILL BE PASSED AS THE VALUES OF component PROPERTY OF &lt;st-fixed&gt;\n     * e.g. &lt;st-fixed component=\"AppHeader\"&gt;\n     */\n    template = `\n        &lt;still-component/&gt;\n    `;\n\n}\n</code></pre>"},{"location":"app-template/#defining-application-top-bar-with-fixed-part","title":"Defining Application top Bar with fixed part","text":"<p>As stated above, AppTemplate fixed part stays stick even when there is navigation. Follow the bellow example:</p> app-template.jsTopBar.jsHomeComponent.jsRegistrationForm.jsListPersons.js Fixed parte in line 18 - This is part of the framework and it's in the project root folder<pre><code>import { Template } from \"./@still/component/super/Template.js\";\n\nexport class AppTemplate extends Template {\n\n    /**\n     * &lt;still-component&gt; is the placeholder where components \n     * should be render both when loading or routing to the component\n     * \n     * &lt;still-fixed&gt; is the specification of a specific component part from the \n     * User interface that needs to be fiexed (e.g. Header, Footer, Menu, Navigation, etc.)\n     * \n     * THIS SHOULD BE CHANGED ACCORDING TO MY LAYOUT WHERE I'M HAVING COMPONENTS FOR\n     * EACH PART AND THE FIXED ONES WIIL BE REFERENCED AS &lt;st-fixed&gt; AND THE COMPONENT\n     * TO BE RENDERED WILL BE PASSED AS THE VALUES OF component PROPERTY OF &lt;st-fixed&gt;\n     * e.g. &lt;st-fixed component=\"AppHeader\"&gt;\n     */\n    template = `\n        &lt;st-fixed component=\"TopBar\"/&gt;\n        &lt;still-component/&gt;\n    `;\n\n}\n</code></pre> This component is placed inside app/component/bar/ folder<pre><code>import { ViewComponent } from \"../../../@still/component/super/ViewComponent.js\";\n\nexport class TopBar extends ViewComponent {\n\n    isPublic = true;\n    template = `\n        &lt;div class=\"main-top-bar\"&gt;\n            This is the Top Bar, it's placed as Fixed\n        &lt;/div&gt;\n\n        &lt;style&gt;\n            .main-top-bar {\n                padding: 10px 3px;\n                background: blue;\n                color: white;\n                text-align: center;\n                font-weight: bold;\n            }\n        &lt;/style&gt;\n    `;\n\n}\n</code></pre> This component is placed inside app/home/ folder<pre><code>import { ViewComponent } from \"../../@still/component/super/ViewComponent.js\";\n\nexport class HomeComponent extends ViewComponent {\n\n    isPublic = true;\n    template = `\n        &lt;div&gt;\n            &lt;p&gt;This is the Home component&lt;/p&gt;\n            &lt;a href=\"#\" (click)=\"goto('RegistrationForm')\"&gt;Register Person&lt;/a&gt;\n            |\n            &lt;a href=\"#\" (click)=\"goto('ListPersons')\"&gt;List Persons&lt;/a&gt;\n        &lt;/div&gt;\n    `;\n\n}\n</code></pre> This component is placed inside app/components/person/ folder<pre><code>import { ViewComponent } from \"../../../@still/component/super/ViewComponent.js\";\n\nexport class RegistrationForm extends ViewComponent {\n\n    isPublic = true;\n    template = `\n        &lt;h1&gt;\n            &lt;p&gt;Person Registration&lt;/p&gt;\n            &lt;a href=\"#\" (click)=\"goto('HomeComponent')\"&gt;Goto Main menu&lt;/a&gt;\n            |\n            &lt;a href=\"#\" (click)=\"goto('ListPersons')\"&gt;Register Person&lt;/a&gt;\n        &lt;/h1&gt;\n    `;\n}\n</code></pre> This component is placed inside app/components/person/ folder<pre><code>import { ViewComponent } from \"../../../@still/component/super/ViewComponent.js\";\n\nexport class ListPersons extends ViewComponent {\n\n    isPublic = true;\n    template = `\n        &lt;h1 style=\"color: green;\"&gt;\n            &lt;p&gt;This is the ListPersons Component&lt;/p&gt;\n            &lt;a href=\"#\" (click)=\"goto('HomeComponent')\"&gt;Goto Main menu&lt;/a&gt;\n            |\n            &lt;a href=\"#\" (click)=\"goto('ListPersons')\"&gt;Register Person&lt;/a&gt;\n        &lt;/h1&gt;\n    `;\n\n}\n</code></pre> <p>Animated result:</p> <p></p> <p></p>"},{"location":"app-template/#creating-a-menu-using-fixed-parts","title":"Creating a menu using Fixed parts","text":"<p>A fixed part recives the component just like <code>&lt;st-element&gt;</code>, such component works the same way a component works in other scenarios inspit being fixed, for this reason we can leverage it for creating more interactive parts like menus.</p> <p>When using navigation in the fixed part, it does not affect the part itself, but the <code>&lt;still-component/&gt;</code> part of the <code>AppTemplate</code>, this makes fixed part the suitable place for transversal menus.</p> app-template.jsTopBar.jsHomeComponent.jsRegistrationForm.jsListPersons.js Fixed parte in line 18 - This is part of the framework and it's in the project root folder<pre><code>import { Template } from \"./@still/component/super/Template.js\";\n\nexport class AppTemplate extends Template {\n\n    /**\n     * &lt;still-component&gt; is the placeholder where components \n     * should be render both when loading or routing to the component\n     * \n     * &lt;still-fixed&gt; is the specification of a specific component part from the \n     * User interface that needs to be fiexed (e.g. Header, Footer, Menu, Navigation, etc.)\n     * \n     * THIS SHOULD BE CHANGED ACCORDING TO MY LAYOUT WHERE I'M HAVING COMPONENTS FOR\n     * EACH PART AND THE FIXED ONES WIIL BE REFERENCED AS &lt;st-fixed&gt; AND THE COMPONENT\n     * TO BE RENDERED WILL BE PASSED AS THE VALUES OF component PROPERTY OF &lt;st-fixed&gt;\n     * e.g. &lt;st-fixed component=\"AppHeader\"&gt;\n     */\n    template = `\n        &lt;st-fixed component=\"TopBar\"/&gt;\n        &lt;still-component/&gt;\n    `;\n\n}\n</code></pre> This component is placed inside app/component/bar/ folder<pre><code>import { ViewComponent } from \"../../../@still/component/super/ViewComponent.js\";\n\nexport class TopMenu extends ViewComponent {\n\n    isPublic = true;\n    template = `\n        &lt;div class=\"top-menu-container\"&gt;\n            &lt;a href=\"#\" (click)=\"goto('HomeComponent')\"&gt;Home&lt;/a&gt;\n            |\n            &lt;a href=\"#\" (click)=\"goto('RegistrationForm')\"&gt;Register Person&lt;/a&gt;\n            |\n            &lt;a href=\"#\" (click)=\"goto('ListPersons')\"&gt;List Persons&lt;/a&gt;\n        &lt;/div&gt;\n\n        &lt;style&gt;\n            .top-menu-container a { color: white; }\n\n            .top-menu-container {\n                padding: 10px 3px;\n                background: blue;\n                font-weight: bold;\n            }\n\n        &lt;/style&gt;\n    `;\n\n}\n</code></pre> This component is placed inside app/home/ folder<pre><code>import { ViewComponent } from \"../../@still/component/super/ViewComponent.js\";\n\nexport class HomeComponent extends ViewComponent {\n\n    isPublic = true;\n    template = `\n        &lt;div&gt;\n            &lt;p&gt;This is the Home component&lt;/p&gt;\n        &lt;/div&gt;\n    `;\n\n}\n</code></pre> This component is placed inside app/components/person/ folder<pre><code>import { ViewComponent } from \"../../../@still/component/super/ViewComponent.js\";\n\nexport class RegistrationForm extends ViewComponent {\n\n    isPublic = true;\n    template = `\n        &lt;h1&gt;\n            &lt;p&gt;Person Registration&lt;/p&gt;\n        &lt;/h1&gt;\n    `;\n}\n</code></pre> This component is placed inside app/components/person/ folder<pre><code>import { ViewComponent } from \"../../../@still/component/super/ViewComponent.js\";\n\nexport class ListPersons extends ViewComponent {\n\n    isPublic = true;\n    template = `\n        &lt;h1 style=\"color: green;\"&gt;\n            &lt;p&gt;This is the ListPersons Component&lt;/p&gt;\n        &lt;/h1&gt;\n    `;\n\n}\n</code></pre> <p>Animated result:</p> <p></p> <p></p>"},{"location":"app-template/#application-stylization","title":"Application Stylization","text":"<p>At the end of the Day the AppTemplate sits on the of the stillUiPlaceholder which is an HTML  placed in the <code>index.html</code> placed in the project root folder, for this reason this (<code>index.html</code>) is the right to use as the source of the App UI styling for the layout by including our <code>.css</code> files in there. index.html Adding my stilesheet file in line 9 - This is a framework file located in the project root folder<pre><code>&lt;!DOCTYPE html&gt;\n&lt;html lang=\"en\"&gt;\n\n&lt;head&gt;\n    &lt;meta charset=\"UTF-8\"&gt;\n    &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=Edge\"&gt;\n    &lt;meta content=\"width=device-width, initial-scale=1\" name=\"viewport\" /&gt;\n    &lt;title&gt;StillJS&lt;/title&gt;\n    &lt;link href=\"path/to/mystyling.css\" rel=\"stylesheet\"&gt;\n    &lt;link href=\"@still/ui/css/still.css\" rel=\"stylesheet\"&gt;\n    &lt;script src=\"@still/index.js\" type=\"module\"&gt;&lt;/script&gt;\n&lt;/head&gt;\n\n&lt;body&gt;\n    &lt;div id=\"stillUiPlaceholder\"&gt;&lt;/div&gt;\n&lt;/body&gt;\n</code></pre> <p></p>"},{"location":"architecture/","title":"Still.js Architecture and Folder Structure","text":""},{"location":"architecture/#scv-architecture","title":"SCV Architecture","text":"<p>Still.js follow it's own architecture approach named Service, Controller and View, as it is quite peculiar on the way it handles and process the components since it does not have bundle/building process, follow the representation diagram:</p> <p></p> <p></p>"},{"location":"architecture/#service-see-example","title":"Service see example","text":"<p>Serves/Provide data to the View, it also takes care of transactions like HTTP requests as well has Global state management. </p> <p>Services are injected (via <code>@Inject</code> annotation) into the component(s) that needs to use it, for this reason they are singleton and are managed by the application container.</p>"},{"location":"architecture/#controller","title":"Controller","text":"<p>Serves the View with behavior and DOM logic. Especially when it comes to complex applications, this is the right place to make large and shared behavior thereby offloading the View.</p> <p>Controllers can be either injected (as singletons) or directly used within components or other controllers. While injection uses a singleton pattern, it's also possible to create new instances manually.</p>"},{"location":"architecture/#view-ui-component","title":"View (UI Component)","text":"<p>A component itself, hence it implements all the visual aspects of the Application, and to some extent some very specific/localized behavior skipping the controller. </p> <p>In small application the View can concentrae everything, from Visual things, to Transactions and Data (like Service), to behavior and DOM manipulation (like Controller).</p> <p> </p>"},{"location":"architecture/#project-folder-structure","title":"Project Folder Structure","text":"<p>When created a Still.js projects, it generates the necessary folder structure and files needed for building the application according to it.</p>  Still.js project folder structure Still.js project folder structure<pre><code>project-root-folder\n|__ @still/\n|__ app/\n|   |\n|__ config/\n|    |__ app-setup.js\n|    |__ route.map.js\n|    |__ app-template.js\n|    |\n|__  index.html\n|__  ...\n</code></pre> <p>The presente folder and files represents the core of the Framework itself, which are needed for building the App:</p> <ul> <li>@still/ Folder with the Framework files to handle all the available features</li> <li>app/ Folder with the Framework files to handle all the available features. Normally the dev will organize the app in different sub-folders according to what layers and files type it'll have, an example would be as follow:</li> </ul> <ul> <li>components - to hold UI components oranized in sub-folders</li> <li>services - to hold services for the components</li> <li>controllers - to hold controllers for the components</li> <li>assets - to hold differents assets (e.g. images) organized in sub-folders</li> <li>libs - to hold external libraries (e.g. jquery)</li> </ul> <ul> <li>config/app-setup.js File for setting generic application and context configuration</li> <li>config/route.map.js File managed by the framework to handle navigation and routes</li> <li>config/app-template.js File for setting up the application skeleton if needed</li> </ul> <p></p>"},{"location":"basic-vs-code-setup/","title":"VS Code Setup Considerations","text":""},{"location":"basic-vs-code-setup/#overview","title":"Overview","text":"<p>Bacuase <code>still-cli</code> is a Vanilla JavaScript Framework that leverages ES module capabilities, when auto-importing one file into another it's required the .js to be in place (see examples bellow), however the editor (e.g. VS Code) won't do that automatically, hence we need a basic setup.</p> <pre><code>//This is correct importing\n\u2705 import { module } from \"MyModule.js\";\n\n//This is wrong importing, will result on net::ERR_ABORTED 404 (Not Found)\n\u274c import { module } from \"MyModule\";\n</code></pre> <p></p>"},{"location":"basic-vs-code-setup/#configure-vscode-to-add-js-when-auto-import","title":"Configure VSCode to add .js when auto-import","text":""},{"location":"components-communication/","title":"Inter Communication","text":"<p>Work in Progress</p> <p>Thee is yet a work in progress in this documentation, it means that some addiotnal content, scenarios and example are yet to be brought, nevertheless the current content cover from the basics to more elaborated scenarios.</p> <p>ViewComponent and BaseService import in CDN/Lone component mode</p> <p>The import (e.g. <code>import { ViewComponent } from \"@still/component/super/ViewComponent.js\"</code>) of ViewComponent and BaseService classes is inexistent CDN mode setup, as this is already provided by CDN itself.</p> <p></p>"},{"location":"components-communication/#overview","title":"Overview","text":"<p>In order to provide ways from components to communicate to each other, Still.js provade with different options thereby covering all scenarios such as Parent to child, Sibling to Sibling, any component to any other(s), follow the documentation.</p> <p></p>"},{"location":"components-communication/#initial-setup","title":"Initial Setup","text":"<ul> <li>Throughout these tutorials/examples the StillAppSetup (<code>app-setup.js</code>) will be as follow:</li> </ul> app-setup.js This is the where Application context aspects are setup. This file resides in the root folder.<pre><code>import { StillAppMixin } from \"./@still/component/super/AppMixin.js\";\nimport { Components } from \"./@still/setup/components.js\";\nimport { AppTemplate } from \"./app-template.js\";\nimport { BiddingDisplay } from \"./app/components/bidding/BiddingDisplay.js\";\n\nexport class StillAppSetup extends StillAppMixin(Components) {\n\n    constructor() {\n        super();\n        //First component to load when running the app\n        this.setHomeComponent(BiddingDisplay);\n        //Set the service folder path (takes place only for service injection like point 3)\n        this.servicePath = 'service/';\n    }\n\n    /** Launch the components in the App container */\n    async init() {\n        return await AppTemplate.newApp();\n    }\n}\n</code></pre>"},{"location":"components-communication/#1-parent-to-child-change-subscription-using-proxy-pubsub","title":"1. Parent to child change Subscription using Proxy (Pub/Sub)","text":"<p>Refer to StillAppSetup above example to view how the first component to load is set.   State Subscription is a way for one Component to listen to another component State changes by subcribing to it. The <code>route.map.js</code> file maps components location. Follow the example:</p> BiddingDisplay.jsBidOffersComponent.jsBiddersList.jsroute.map.js Project folder structure This is the parent component<pre><code>import { ViewComponent } from \"../../../@still/component/super/ViewComponent.js\";\nimport { BidOffersComponent } from \"./BidOffersComponent.js\";\n\nexport class BiddingDisplay extends ViewComponent {\n\n    isPublic = true;\n\n    /** @Proxy @type { BidOffersComponent } */\n    bidOfferProxy; //This is assignet in the proxy prop of the &lt;st-element&gt; line 14\n\n    template = `\n        &lt;st-element \n            component=\"BidOffersComponent\"\n            proxy=\"bidOfferProxy\"\n        &gt;\n        &lt;/st-element&gt;\n        &lt;st-element component=\"BiddersList\"&gt;&lt;/st-element&gt;\n    `;\n\n    /** Component Hook which takes place when it's completly render and startder */\n    stAfterInit() {\n        /** This is needed so parent component only try to subscribe to state \n         * after child is completly loaded */\n        this.bidOfferProxy.on('load', () =&gt; {\n            // This proxy represents BidOffersComponent component\n            this.bidOfferProxy.offerAmmount.onChange((value) =&gt; {\n                console.log(`Theres is a new offer of ${value}`);\n            });\n        });\n    }\n\n}\n</code></pre> This child component has a proxy in the parent<pre><code>import { ViewComponent } from \"../../../@still/component/super/ViewComponent.js\";\n\nexport class BidOffersComponent extends ViewComponent {\n\n    isPublic = true;\n\n    offerAmmount = 0;\n\n    template = `\n        &lt;button (click)=\"increase()\"&gt;Increase my offer&lt;/button&gt;\n        I'm willing to offer @offerAmmount.\n    `;\n\n    /* Child component updates itself, but parent classe \n     * can also call this method thereby beng able to update\n     * the child value \n     * */\n    increase(){\n        this.offerAmmount = this.offerAmmount.value + 5;\n    }\n\n}\n</code></pre> <pre><code>import { ViewComponent } from \"../../../@still/component/super/ViewComponent.js\";\n\nexport class BiddersList extends ViewComponent {\n\n    isPublic = true;\n    template = `\n        &lt;p&gt;Here goes the list of bidders.&lt;/p&gt;\n    `;\n\n}\n</code></pre> <pre><code>export const stillRoutesMap = {\n    viewRoutes: {\n        regular: {\n            BiddingDisplay: {\n                path: \"app/components/bidding\",\n                url: \"/bid/display\"\n            },\n            BidOffersComponent: {\n                path: \"app/components/bidding\",\n                url: \"/bid/offer\"\n            },\n            BiddersList: {\n                path: \"app/components/bidding\",\n                url: \"/bid/bidder\"\n            }\n        },\n        lazyInitial: {}\n    }\n}\n</code></pre> Project folder structure<pre><code>project-root-folder\n|__ @still/\n|__ app/\n|    |\n|    |__ components/\n|    |   |__ bidding/\n|    |   |   |__ BiddingDisplay.js\n|    |   |   |__ BidOffersComponent.js\n|    |   |   |__ BiddersList.js\n|    |   |   |\n|__ config/\n|    |__ app-setup.js\n|    |__ route.map.js\n|__  ...\n</code></pre> <p>Proxy approach consideration</p> <p>Parent component can Subscribe to its childrens State through 2 means, the <code>@Proxy</code> way, and/or the reference (<code>ref</code>) way.</p> <ul> <li> <p>For using a proxy, the Parent component needs to create a property annotated with both <code>@Proxy</code> and <code>@type</code> annotation, and <code>@Proxy</code> comes first, the type will be the component class which the Proxy represents.</p> </li> <li> <p>Proxy readiness is needed to subscribe to its state, in this case subscription happens when child component is fully ready, hence we're doing <code>this.bidOfferProxy.on('load', callBackFunction)</code> which is placed in the stAfterInit() Hook, and my callBackFunction is where I implement the state subscription itself.</p> </li> <li> <p>Parent can access anything which is public from the Proxy property as shown in line 25, therefore, to subscribe to a State of the child, we only need to specify <code>.onChange()</code> that which recieves a closure/function, this closure recieves the new values as first parameter.</p> </li> <li> <p>A component can subscribe to change to itself, therefore this is automatically done when the State is bound to the template, in addition to that, it can also be done through the <code>.onChange()</code> method, and this is done by using the stAfterInit() Hook as well.</p> </li> </ul> <p></p> <p></p>"},{"location":"components-communication/#2-adjacent-sibling-components-reactive-communication-using-reference-pubsub","title":"2. Adjacent (sibling) components reactive communication using Reference (Pub/Sub)","text":"<p>Refer to StillAppSetup above example to view how the first component to load is set. </p> <p>State Subscription is a way for one Component to listen to another component State changes by subcribing to it. The <code>route.map.js</code> file maps components location. Follow the example:</p> BiddingDisplay.jsBidOffersComponent.jsBiddersList.jsroute.map.js Project folder structure This is the parent component<pre><code>import { ViewComponent } from \"../../../@still/component/super/ViewComponent.js\";\n\nexport class BiddingDisplay extends ViewComponent {\n\n    isPublic = true;\n\n    template = `\n        &lt;st-element \n            component=\"BidOffersComponent\"\n            ref=\"BidOffersDisplayRef\"\n        &gt;\n        &lt;/st-element&gt;\n        &lt;st-element component=\"BiddersList\"&gt;&lt;/st-element&gt;\n    `;\n\n}\n</code></pre> This child component has a ref stated in the parent<pre><code>import { ViewComponent } from \"../../../@still/component/super/ViewComponent.js\";\n\nexport class BidOffersComponent extends ViewComponent {\n\n    isPublic = true;\n    totalBidders = 0;\n\n    template = `\n        Total bidders now is @totalBidders.\n    `;\n\n    /* Child component updates itself, but parent and sibling classe can \n    * also call this method thereby beng able to update the child value \n    * */\n    onNewBiderEntering() {\n        console.log(`New bidder enter to the list and his bid is 0 for now`);\n    }\n\n}\n</code></pre> This child component access his sibling through the reference<pre><code>import { ViewComponent } from \"../../../@still/component/super/ViewComponent.js\";\nimport { BidOffersComponent } from \"./BidOffersComponent.js\";\n\nexport class BiddersList extends ViewComponent {\n\n    isPublic = true;\n\n    /** @Prop @type { BidOffersComponent } */\n    bidOfferInstance;\n\n    template = `\n        Here goes the list of bidders.\n        &lt;button (click)=\"addBidder()\"&gt;Admit new Bidder&lt;/button&gt;\n    `;\n\n    constructor() {\n        super(); //Supper is needed to be called according to JavaScript standards\n\n        // stWhenReady() Hook detects when the sibling component is available\n        this.stWhenReady(() =&gt; {\n            // Assigning the sibling instance to the property\n            this.bidOfferInstance = Components.ref('BidOffersDisplayRef');\n        });\n\n    }\n\n    addBidder() {\n        // Call sibling component method\n        this.bidOfferInstance.onNewBiderEntering();\n\n        // Updating the sibling component State through the reference\n        const prevTotalBidders = this.bidOfferInstance.totalBidders.value;\n        this.bidOfferInstance.totalBidders = prevTotalBidders + 1;\n    }\n\n}\n</code></pre> <pre><code>export const stillRoutesMap = {\n    viewRoutes: {\n        regular: {\n            BiddingDisplay: {\n                path: \"app/components/bidding\",\n                url: \"/bid/display\"\n            },\n            BidOffersComponent: {\n                path: \"app/components/bidding\",\n                url: \"/bid/offer\"\n            },\n            BiddersList: {\n                path: \"app/components/bidding\",\n                url: \"/bid/bidder\"\n            }\n        },\n        lazyInitial: {}\n    }\n}\n</code></pre> Project folder structure<pre><code>project-root-folder\n|__ @still/\n|__ app/\n|    |\n|    |__ components/\n|    |   |__ bidding/\n|    |   |   |__ BiddingDisplay.js\n|    |   |   |__ BidOffersComponent.js\n|    |   |   |__ BiddersList.js\n|    |   |   |\n|__ config/\n|    |__ app-setup.js\n|    |__ route.map.js\n|__  ...\n</code></pre> <p>Reference (ref) approach consideration</p> <ul> <li> <p>Just like the <code>@Proxy</code>, reference (<code>ref</code>) way needs to be defined in the tag itself, which then makes it available to be accessed through the Components.ref() method as we can see in the second sibling ( BiddersList ).</p> </li> <li> <p>Proxies and references are alike except for the scope they can be accessed, as Proxy only the Father can acces it (see proxy example), and the reference can be access by any component as long as it's sibling or active in the same moment, therefore, Parent component can access child through reference the same way the sibling does.</p> </li> </ul> <p></p> <p></p>"},{"location":"components-communication/#3-global-state-management-reactively-components-communication-with-service","title":"3. Global state management Reactively - Components communication with Service","text":"<p>Refer to StillAppSetup above example to view how the first component to load is set. </p> <p>Services enable component communication without being tied to a specific component, ensuring state persistence even after a component is unloaded. The <code>route.map.js</code> file maps components location, follow the code example:</p> BiddingDisplay.jsBidOffersComponent.jsBiddersList.jsBiddingService.jsroute.map.js Project folder structure This is the parent component<pre><code>import { ViewComponent } from \"../../../@still/component/super/ViewComponent.js\";\nimport { BiddingService } from \"../../service/BiddingService.js\";\n\nexport class BiddingDisplay extends ViewComponent {\n\n    isPublic = true;\n\n    /** Service declaration, will get injected automatically from the service\n     *  path defined in the application level (StillAppSetup) in app-setup.js (last tab)\n     * @Inject\n     * @type { BiddingService } */\n    bService;\n\n\n    template = `\n        &lt;st-element component=\"BiddersList\"&gt;&lt;/st-element&gt;\n        &lt;st-element \n            component=\"BidOffersComponent\"\n        &gt;\n        &lt;/st-element&gt;\n    `;\n\n    /** Component Hook which takes place when it's completly render and startder */\n    stAfterInit() {\n        /** This is needed so parent component only try to subscribe to state \n         * after child is completly loaded */\n        this.bService.on('load', () =&gt; { //Check service readiness\n            //Bellow, it Subscribe to ServiceEvent variable (countryStore)\n            this.bService.countryStore.onChange(newValue =&gt; {\n                console.warn(`New country entered the Bid, follow the list: `, newValue);\n            });\n        });\n\n    }\n\n}\n</code></pre> This child component has a ref stated in the parent<pre><code>import { ViewComponent } from \"../../../@still/component/super/ViewComponent.js\";\nimport { BiddingService } from \"../../service/BiddingService.js\";\n\nexport class BidOffersComponent extends ViewComponent {\n\n    isPublic = true;\n\n    /** @Inject @type { BiddingService } */\n    bService;\n\n    template = `\n        &lt;p&gt;\n            &lt;button (click)=\"exitTheBid()\"&gt;Exit the bidding&lt;/button&gt;\n        &lt;/p&gt;\n    `;\n\n    exitTheBid() {\n        let countryStore = this.bService.countryStore.value;\n        const myCountry = 'Australia';\n\n        // Filter out every country but Australia\n        countryStore = countryStore.filter(country =&gt; country != myCountry);\n\n        // Update the store with Australia removed from the list\n        this.bService.countryStore = countryStore;\n    }\n\n}\n</code></pre> This child component access his sibling through the reference<pre><code>import { ViewComponent } from \"../../../@still/component/super/ViewComponent.js\";\nimport { BiddingService } from '../../service/BiddingService.js';\n\nexport class BiddersList extends ViewComponent {\n\n    isPublic = true;\n\n    /** \n     * @Inject\n     * @type { BiddingService } */\n    bService;\n\n    /** Not a state but a prop, hence the annotation\n     * @Prop */\n    countriesList = ['Bulgaria', 'Canada', 'Denmark', 'Ethiop', 'France', 'Ghana']\n\n    template = `\n        &lt;p&gt;Here goes the list of bidders.&lt;/p&gt;\n        &lt;button (click)=\"addMoreCountry()\"&gt;Adde new country&lt;/button&gt;\n    `;\n\n    addMoreCountry() {\n        /** Retrieve and log the current/initial state */\n        const countryState = this.bService.countryStore.value;\n        console.log(`----&gt; Country Store before updating: `, countryState);\n\n        /** Get the next country from the  */\n        const newCountry = this.countriesList[countryState.length - 1];\n        /** Updating the store and re-assigning it to the service */\n        countryState.push(newCountry);\n        this.bService.countryStore = countryState;\n\n        /** Retrieve and log the state after update from store */\n        const updatedCountryState = this.bService.countryStore.value;\n        console.log(`----&gt; Country Store after updating: `, updatedCountryState);\n    }\n}\n</code></pre> Service Path is defined in StillAppSetup class<pre><code>import { BaseService, ServiceEvent } from \"../../@still/component/super/service/BaseService.js\";\n\nexport class BiddingService extends BaseService {\n\n    /** An array with a single country is being assigner */\n    countryStore = new ServiceEvent(['Australia']);\n\n}\n</code></pre> <pre><code>export const stillRoutesMap = {\n    viewRoutes: {\n        regular: {\n            BiddingDisplay: {\n                path: \"app/components/bidding\",\n                url: \"/bid/display\"\n            },\n            BidOffersComponent: {\n                path: \"app/components/bidding\",\n                url: \"/bid/offer\"\n            },\n            BiddersList: {\n                path: \"app/components/bidding\",\n                url: \"/bid/bidder\"\n            }\n        },\n        lazyInitial: {}\n    }\n}\n</code></pre> Project folder structure<pre><code>project-root-folder\n|__ @still/\n|__ app/\n|    |\n|    |__ components/\n|    |   |__ bidding/\n|    |   |   |__ BiddingDisplay.js\n|    |   |   |__ BidOffersComponent.js\n|    |   |   |__ BiddersList\n|    |   |   |\n|    |__ service/\n|    |   |__ bidding/Service.js\n|    |   |\n|__ config/\n|    |__ app-setup.js\n|    |__ route.map.js\n|__  ...\n</code></pre> <p>Still.js Service considerations</p> <ul> <li> <p>Services are singleton and for them to be injected we use the <code>@Inject</code> annotation which can also be combined with <code>@Path</code> annotation allowing for specification of the service file path, also, it's required to define the injection <code>@type</code> just like we do for a Proxy.</p> </li> <li> <p>Just the same as <code>@Proxy</code>, Service need to be ready to be used, then again we call the the serviceName.on('load', callBackFunc), where serviceName is the variable name annotated with <code>@Inject</code>.</p> </li> <li> <p>The concept behind the service is that it can be composed by different type of features such as store/ServiceEvent, regular state and methods (e.g. to implement API call or complex logic implementation), for this example only ServiceEvent/Store is being used.</p> </li> <li> <p>ServiceEvent variable in the Service are the ones which allow for reactive behavior through the means os subscription the same way it happens with component state.</p> </li> </ul> <p></p>"},{"location":"components-communication/#31-defining-service-path-using-path-annotation","title":"3.1. Defining Service path using @Path annotation","text":"<p>Refer to StillAppSetup above example to view how the first component to load is set. </p> <p>Still.js offers the <code>@Path</code> annotation to specify the folder path of an injecting service, ensuring a more granular project structured organization. The <code>route.map.js</code> file maps component locations. Follow the example:</p> BiddingDisplay.jsBiddersList.jsCustomersService.jsroute.map.js Project folder structure This is the parent component which subscribe to the service store<pre><code>import { ViewComponent } from \"../../../@still/component/super/ViewComponent.js\";\nimport { CustomersService } from \"../../service/api/CustomersService.js\";\n\nexport class BiddingDisplay extends ViewComponent {\n\n    isPublic = true;\n\n    /** Service declaration, will get injected automatically due to Inject anottation\n     *  from the specified Path path due to the annotation\n     * @Inject\n     * @Path service/api/\n     * @type { CustomersService } */\n    custService;\n\n    template = `\n        &lt;st-element component=\"BiddersList\"&gt;&lt;/st-element&gt;\n    `;\n\n    /** Component Hook which takes place when it's completly render and startder */\n    stAfterInit() {\n\n        this.custService.on('load', () =&gt; { //Check service readiness\n            //Bellow, it Subscribes to ServiceEvent variable (totalCustomers)\n            this.custService.totalCustomers.onChange(newValue =&gt; {\n                console.log(`Total customer was updated to: `, newValue);\n            });\n        });\n\n    }\n\n}\n</code></pre> This is the parent component which subscribe to the service store<pre><code>import { ViewComponent } from \"../../../@still/component/super/ViewComponent.js\";\nimport { CustomersService } from '../../service/api/CustomersService.js'\n\nexport class BiddersList extends ViewComponent {\n\n    isPublic = true;\n\n    /** Parameter after sertice path is infact the folder\n     *  where it's (CustomersService.js) placed\n     * @Inject\n     * @Path service/api/\n     * @type { CustomersService } */\n    customerService;\n\n    template = `\n        &lt;p&gt;Here goes the list of bidders.&lt;/p&gt;\n        &lt;button (click)=\"updateTotalCustomer()\"&gt;Up customers&lt;/button&gt;\n    `;\n\n    updateTotalCustomer() {\n        const currentValue = this.customerService.totalCustomers.value;\n        /** Update the value of the of the Store variable in the service */\n        this.customerService.totalCustomers = currentValue + 10;\n    }\n}\n</code></pre> This is the parent component which subscribe to the service store<pre><code>import { BaseService, ServiceEvent } from '../../../@still/component/super/service/BaseService.js';\nexport class CustomersService extends BaseService {\n\n    totalCustomers = new ServiceEvent(0);\n\n}\n</code></pre> <pre><code>export const stillRoutesMap = {\n    viewRoutes: {\n        regular: {\n            BiddingDisplay: {\n                path: \"app/components/bidding\",\n                url: \"/bid/display\"\n            },\n            BidOffersComponent: {\n                path: \"app/components/bidding\",\n                url: \"/bid/offer\"\n            },\n            BiddersList: {\n                path: \"app/components/bidding\",\n                url: \"/bid/bidder\"\n            }\n        },\n        lazyInitial: {}\n    }\n}\n</code></pre> Project folder structure<pre><code>project-root-folder\n|__ @still/\n|__ app/\n|    |\n|    |__ DIRcomponents\n|    |   |__ bidding/\n|    |   |   |__ BiddingDisplay.js\n|    |   |   |__ BiddersList.js\n|    |   |   |\n|    |__ service/\n|    |   |__ api\n|    |   |   |__ CustomersService.js\n|    |   |   |\n|__ config/\n|    |__ app-setup.js\n|    |__ route.map.js\n|__  ...\n</code></pre> <p> In addition the the different component intecommunication approached in thispage, Still.js also provide Parent to Child communication approach which allowpassing properties and methods from parent to child as explained in the Component to Component communication.  </p>"},{"location":"components-nesting-3%2B/","title":"Multi level (3+) nesting","text":""},{"location":"components-nesting-3%2B/#multi-level-nesting-component-with-3-offsprings","title":"Multi-level nesting component with 3+ offsprings","text":""},{"location":"components-nesting-3%2B/#overview","title":"Overview","text":"<p>Frameworks use custom tags that browsers don't recognize, leading to heavy and recursive computation. To reduce this, Still.js limits component nesting to three levels\u2014Grandparent \u2192 Parent \u2192 Child, thereby improving performance and minimize computation.</p> <p>However, Stilljs yet encourages the use of more than 3 levels of nesting, given that from the 4th level it should be used <code>Web Component</code> register to the browser. It's recommended for those to be light component like generics widgets (e.g. button, card, wrapper, template).</p> <p></p>"},{"location":"components-nesting-3%2B/#nesting-component-scenarios","title":"Nesting component scenarios","text":""},{"location":"components-nesting-3%2B/#design-perspective-addressing-nested-component","title":"Design perspective - Addressing Nested component","text":"<p>In design, nesting components should be done only when necessary. For example, in a product list, unless they are reused elsewhere, elements like <code>buttons</code> or <code>images</code> does not need to be separate components, they can be kept inside Product component. Even if subparts present some complexity,   overengineering ca be avoided by planing component structure thoughtfully.</p> <p></p>"},{"location":"components-nesting-3%2B/#embeding-web-component-inside-stilljs-component","title":"Embeding Web component inside Still.js component:","text":"<p>Web Components are registered with the browser, making them fully recognized and manageable custom tags that support unlimited nesting. Still.js leverages them effectively due to its vanilla JavaScript foundation. </p> <p>Bellow is the project structure for this coming example:</p>  Project folder structureapp-setup.jsCustomRedDiv.jsCustomRedDiv.js Project folder structure<pre><code>project-root-folder\n|__ @still/\n|__ app/\n|    |\n|    |__ components/\n|    |   |__ Home.js\n|    |__ webcomponents/\n|    |   |__ CustomRedDiv.js\n|    |   |   |\n|__ config/\n|    |__ app-setup.js\n|__  ...\n</code></pre> <pre><code>import { StillAppMixin } from \"../@still/component/super/AppMixin.js\";\nimport { Components } from \"../@still/setup/components.js\";\nimport { HomeComponent } from \"../app/home/HomeComponent.js\";\nimport { CustomRedDiv } from \"../app/wcomp/CustomRedDiv.js\";\nimport { AppTemplate } from \"./app-template.js\";\n\nexport class StillAppSetup extends StillAppMixin(Components) {\n\n    constructor() {\n        super();\n        this.setHomeComponent(HomeComponent);\n        // This is the custom web component\n        this.register(CustomRedDiv);\n    }\n\n    async init() {\n        return await AppTemplate.newApp();\n    }\n\n}\n</code></pre> Web Component<pre><code>export class CustomRedDiv extends HTMLElement {\n\n    connectedCallback(){\n\n        const wrappedContent = this.innerHTML;\n        const style = `\n            &lt;style&gt;\n                custom-red-div div{ border: 1px solid red; }\n            &lt;/style&gt;\n        `;\n        // Content that will be displayed in the when the component renders \n        this.innerHTML = `${style}&lt;div&gt;${wrappedContent}&lt;/div&gt;`;\n    }\n}\n\nwindow.customElements.define('custom-red-div', CustomRedDiv);\n</code></pre> Web Component<pre><code>import { ViewComponent } from \"../../@still/component/super/ViewComponent.js\";\n\nexport class Home extends ViewComponent {\n\n    isPublic = true;\n\n    template = `\n    &lt;div&gt;\n        My Home content\n        &lt;custom-red-div&gt;This content is handled by Web component&lt;/custom-red-div&gt;\n    &lt;/div&gt;\n    `;\n\n}\n</code></pre> <p>In the example, the Web Component is placed in a separate webcomponents folder for clarity, but it could just as well be stored alongside regular Still.js components in the same folder.</p> <p>Once created, the Web component needs to be register in the Still application context so it becomes available accross all other components through the application.</p>"},{"location":"components-nesting-3%2B/#in-summary","title":"In Summary","text":"<p>Still.js supports component nesting up to 3 levels (parent \u2192 child \u2192 grandchild). For deeper levels, it recommends using Web Components starting from the great-grandchild level onward.</p> <p>Limiting to 3 nesting levels maintains performance; beyond that, use Web Components since they're directly registered, managed and parsed by the browser.</p>"},{"location":"components-nesting-3%2B/#enjoy-nesting-component","title":"Enjoy nesting component","text":""},{"location":"components-private/","title":"Private Components","text":""},{"location":"components-private/#overview","title":"Overview","text":"<p>For the sake of user permission aspect, Private components in Still.js help manage user authorization for navigation and rendering. If a component is not public (<code>isPublic = false</code> or unset), custom logic is required to control its visibility. Still.js allows blacklisting and whitelisting components based on custom requirements, overriding the <code>isPublic</code> flag regardless of its value (true or false).</p> <p> </p>"},{"location":"components-private/#1-making-component-private","title":"1. Making component private","text":"NewAccountForm.jsCheckingAccount.jsCheckingAccount.jsapp-setup.jsroute.map.js Project folder structure This is the entry point component which is set as Home in app-setup.js<pre><code>import { ViewComponent } from \"../../../@still/component/super/ViewComponent.js\";\n\nexport class NewAccountForm extends ViewComponent {\n    // Bellow flag makes the component public\n    isPublic = true;\n    template = `\n        &lt;section&gt;\n            This is the UI for creating account&lt;br&gt;\n            More Options&lt;br&gt;&lt;br&gt;\n            &lt;a href=\"#\" (click)=\"goto('SavingAccount')\"&gt;List Saving accounts&lt;/a&gt;\n            |\n            &lt;a href=\"#\" (click)=\"goto('CheckingAccount')\"&gt;List Checking accounts&lt;/a&gt;\n        &lt;/section&gt;\n    `;\n}\n</code></pre> This is a private component<pre><code>import { ViewComponent } from \"../../../@still/component/super/ViewComponent.js\";\n\nexport class CheckingAccount extends ViewComponent {\n    // Since the flag is set to false the component is then private\n    isPublic = false;\n    template = `\n        &lt;div&gt;\n            Here will be the list of Checking accounts\n        &lt;/div&gt;\n    `;\n\n}\n</code></pre> This is a private component<pre><code>import { ViewComponent } from \"../../../@still/component/super/ViewComponent.js\";\n\nexport class SavingAccount extends ViewComponent {\n\n    /** The isPublic flag is not set making it to default to private */\n\n    template = `\n        &lt;div&gt;\n            The Saving accounts will be displayed here\n        &lt;/div&gt;\n    `;\n}\n</code></pre> This is the where Application context aspects are setup. This file is in the root folder.<pre><code>import { StillAppMixin } from \"./@still/component/super/AppMixin.js\";\nimport { Components } from \"./@still/setup/components.js\";\nimport { AppTemplate } from \"./app-template.js\";\nimport { NewAccountForm } from \"./app/components/BankAccount/NewAccountForm.js\";\n\nexport class StillAppSetup extends StillAppMixin(Components) {\n\n    constructor() {\n        super();\n        //Bellow the entry point component is being set\n        this.setHomeComponent(NewAccountForm);\n    }\n\n    async init() {\n        return await AppTemplate.newApp();\n    }\n\n}\n</code></pre> Routes will be added and manage automatically from here when creating the component using still-cli<pre><code>export const stillRoutesMap = {\n    viewRoutes: {\n        regular: {\n            SavingAccount: {\n                path: \"app/components/BankAccount\",\n                url: \"/minha/url/like/rest\"\n            },\n            CheckingAccount: {\n                path: \"app/components/BankAccount\",\n                url: \"/bankaccoun/checking-account\"\n            },\n            NewAccountForm: {\n                path: \"app/components/BankAccount\",\n                url: \"/bankaccoun/new-account-form\"\n            },\n        },\n        lazyInitial: {}\n    }\n}\n</code></pre> Project folder structure<pre><code>project-root-folder\n|__ @still/\n|__ app/\n|    |\n|    |__ components/\n|    |   |__ BankAccount/\n|    |   |   |__ NewAccountForm.js\n|    |   |   |__ CheckingAccount.js\n|    |   |   |__ SavingAccount.js\n|    |   |   |\n|__ config/\n|    |__ app-setup.js\n|    |__ route.map.js\n|__  ...\n</code></pre> <p>In the example above, the NewAccountForm component includes buttons to navigate to private components, causing an <code>Unauthorized acces</code> warning and not rendering the component. To allow navigation, two approaches can be used separately or in combination and they can be set through the <code>StillAppSetup</code> (app-setup.js file):</p> <ul> <li> <p>setAuthN - For the Application context, when the AuthN is set to true (<code>this.setAuthN(true)</code>), it understands that navigation to/ embeding such component can happen at all levels, anyway, there might be some exception which cannot be addressed here.</p> </li> <li> <p>setWhiteList - It's possible to specify a list of components that should be whitelisted, by doing that, even if the component is private, it'll always be accessible.</p> </li> </ul> <p></p> <p></p>"},{"location":"components-private/#11-allowing-private-component-access-through-authn-flag","title":"1.1 Allowing private component access through <code>authN</code> flag","text":"<p>The <code>authN</code> flag is configured at the application level in the <code>StillAppSetup</code> class (<code>app-setup.js</code>). It is set using <code>.setAuthN(true)</code> in the custom authentication logic to indicate that the user is authenticated, allowing access to all components, including private ones. Having the same sample project from point 1 only edit the <code>app-setup.js</code> as follow:</p> app-setup.js This is the where Application context aspects are setup. This file is in the root folder.<pre><code>import { StillAppMixin } from \"./@still/component/super/AppMixin.js\";\nimport { Components } from \"./@still/setup/components.js\";\nimport { AppTemplate } from \"./app-template.js\";\nimport { NewAccountForm } from \"./app/components/BankAccount/NewAccountForm.js\";\n\nexport class StillAppSetup extends StillAppMixin(Components) {\n\n    constructor() {\n        super();\n        //Bellow the entry point component is being set\n        this.setHomeComponent(NewAccountForm);\n        //This informs the application that user can access all component\n        this.setAuthN(true);\n    }\n\n    async init() {\n        return await AppTemplate.newApp();\n    }\n}\n</code></pre> <p></p> <p></p>"},{"location":"components-private/#12-using-whitelist-to-allow-access-to-private-component","title":"1.2 Using <code>whiteList</code> to allow access to Private component","text":"<p>In addition to <code>setAuthN</code> flag approach, <code>setWhiteList</code> is another way to make a private component accessible, in this case we have to pass an array of all components that we want to make accessible although it's private. Having the same sample project from point 1 only edit the <code>app-setup.js</code> as follow:</p> app-setup.js This is the where Application con, follow the text aspects are setup. This file is in the root folder.<pre><code>import { StillAppMixin } from \"./@still/component/super/AppMixin.js\";\nimport { Components } from \"./@still/setup/components.js\";\nimport { AppTemplate } from \"./app-template.js\";\nimport { CheckingAccount } from \"./app/components/BankAccount/CheckingAccount.js\";\nimport { NewAccountForm } from \"./app/components/BankAccount/NewAccountForm.js\";\nimport { SavingAccount } from \"./app/components/BankAccount/SavingAccount.js\";\n\nexport class StillAppSetup extends StillAppMixin(Components) {\n\n    constructor() {\n        super();\n        //Bellow the entry point component is being set\n        this.setHomeComponent(NewAccountForm);\n        const whiteListComponents = [SavingAccount, CheckingAccount];\n        //Make components whitelisted by passing it to setWhiteList App configuration\n        this.setWhiteList(whiteListComponents);\n    }\n\n    async init() {\n        return await AppTemplate.newApp();\n    }\n\n}\n</code></pre> <p> <p>Whitelist behind the scenes</p> <p><code>whiteList components</code> can only be set once, means, if <code>setWhiteList()</code> is call more than once, only the first call will take affect, therefore changing it the runtime does not work, nevertheless, multiples list can yet be set and combined with the appropriate application logic/flow, so alternative flows can take place.</p> <p></p> <p></p>"},{"location":"components-private/#2-using-blacklist-to-make-a-component-private-not-accessible","title":"2 Using <code>blackList</code> to make a component private (not accessible)","text":"<p>The blacklist is used to restrict access to specific components or parts of the application, even for authenticated users. When combined with business logic, it ensures that components listed in the blacklist remain inaccessible\u2014regardless of a successful <code>.setAuthN(true)</code> call\u2014preventing access via both navigation and embedding. Having the same sample project from point 1 only edit the <code>app-setup.js</code> as follow:</p> app-setup.js This is the where Application con, follow the text aspects are setup. This file is in the root folder.<pre><code>import { StillAppMixin } from \"./@still/component/super/AppMixin.js\";\nimport { Components } from \"./@still/setup/components.js\";\nimport { AppTemplate } from \"./app-template.js\";\nimport { CheckingAccount } from \"./app/components/BankAccount/CheckingAccount.js\";\nimport { NewAccountForm } from \"./app/components/BankAccount/NewAccountForm.js\";\n\nexport class StillAppSetup extends StillAppMixin(Components) {\n\n    constructor() {\n        super();\n        //Bellow the entry point component is being set\n        this.setHomeComponent(NewAccountForm);\n\n        const userAuthSuccess = true;\n        if (userAuthSuccess) {\n            this.setAuthN(true);\n        }\n\n        //Revokes access to CheckingAccount provided by authN flag\n        this.setWhiteList([CheckingAccount]);\n    }\n\n    async init() {\n        return await AppTemplate.newApp();\n    }\n\n}\n</code></pre> <p>Blacklist precedence and considerations</p> <ul> <li> <p>Blacklist has hte highest precedence in case it's combined with <code>authN</code> flag or <code>whiteList</code>, no matter in what order they are called, once <code>blackList</code> takes this hieghst priority if when a component is found there.</p> </li> <li> <p><code>blackList components</code> can only be set once, means, just as the <code>whiteList</code> (see explanation).</p> </li> </ul> <p></p> <p>Component rendering will be affectid by the component visibility (public, private), nevertheless, therefore, this happens in the application level, however Still.js also provides with (renderIf) directive which allows controling component in the component level by putting such directive in the template for a specific HTML tag as shown in this example.</p> <p></p>"},{"location":"components/","title":"Fundamentls","text":"<p>Work in Progress</p> <p>Thee is yet a work in progress in this documentation, it means that some addiotnal content, scenarios and example are yet to be brought, nevertheless the current content cover from the basics to more elaborated scenarios.</p> <p>ViewComponent and BaseService import in CDN/Lone component mode</p> <p>The import (e.g. <code>import { ViewComponent } from \"@still/component/super/ViewComponent.js\"</code>) of ViewComponent and BaseService classes is inexistent CDN mode setup, as this is already provided by CDN itself.</p> <p></p>"},{"location":"components/#overview","title":"Overview","text":"<ul> <li> <p>In Still.js, a Component represents any UI output, from a full application to a widget or a microfrontend. Components can be reusable, navigable (for UI/pages), and embedded within other applications.</p> </li> <li> <p>A component must extend <code>ViewComponent</code> and define a <code>template</code> for rendering. If initialization logic is needed, a Special methods (lifecycle/Hook) can be implemented, if constructor is in place <code>super()</code> needs to be called as first line.</p> </li> <li> <p>For proper localization/routing, both Path and URL must be defined in <code>route.map.js</code>. However, this is handled automatically when creating components via still-cli (check bellow). The <code>app-setup.js</code> manages application-level configurations, but for these tutorials we'll be touching it just to set the initial component we want to be loaded.</p> </li> </ul> <p>In Still.js, the template variable contains pure HTML, a defined WebComponent, &lt;st-element&gt; tags, or a combination of these, as it is based on vanilla web technologies (HTML, CSS, and JavaScript).</p>"},{"location":"components/#1-simple-example","title":"1. Simple example","text":"Project folder structureapp-setup.jsroute.map.jsHomeComponent.js Project folder structure<pre><code>project-root-folder\n|__ @still/\n|__ app/\n|    |\n|    |__ home/\n|    |   |__ HomeComponent.js\n|    |\n|__ config/\n|    |__ app-setup.js\n|    |__ route.map.js\n|__  ...\n</code></pre> This is the where Application context aspects are setup. This file is in the root folder.<pre><code>import { StillAppMixin } from \"./@still/component/super/AppMixin.js\";\nimport { Components } from \"./@still/setup/components.js\";\nimport { AppTemplate } from \"./app-template.js\";\nimport { HomeComponent } from \"./app/home/HomeComponent.js\";\n\nexport class StillAppSetup extends StillAppMixin(Components) {\n\n    constructor() {\n        super();\n        //Defines the first component to load\n        this.setHomeComponent(HomeComponent);\n    }\n\n    async init() {\n        //Loads the app container and the initial component set at line 11\n        return await AppTemplate.newApp();\n    }\n\n}\n</code></pre> Routes will be added and manage automatically from here when creating the component using still-cli<pre><code>export const stillRoutesMap = {\n    viewRoutes: {\n        regular: {\n            HomeComponent: { path: \"app/home\", url: \"/HomeComponent\" }\n        },\n        lazyInitial: {}\n    }\n}\n</code></pre> HomeComponent.js<pre><code>import { ViewComponent } from \"../../@still/component/super/ViewComponent.js\";\n\nexport class HomeComponent extends ViewComponent {\n\n    /** Need in any component as long as not dealing with parts \n     * only accessible in case of authenticated user\n     * */\n    isPublic = true;\n\n    /**\n     * constructor for still.js might be needed in very specific\n     * situations (e.g. for using whenReady() Hook)\n    */\n    constructor() {\n        super();\n    }\n}\n</code></pre> <p>Conceptually, all components extends from ViewComponent, and, behide the, therefore, such extending component can serve as a whole page or a simple part of a specific page.</p> <p> </p>"},{"location":"components/#component-creation","title":"Component Creation","text":"<ul> <li> <p>The recommended way fo Component creation is by using the still-cli utility (@stilljs/cli on npm), for that we run the command as follow:</p> <pre><code>npx still create component path/to/MyComponentName\n</code></pre> <p>Component creation folder context</p> <p>The component creation command instruction needs to be run inside s Still.js project, or in the <code>app/</code> (which is inside the Still.js project) folder or a subfolder of the <code>app/</code> folder</p> <p></p> </li> <li> <p>The create command for component options also provides with aliases, in this case we can abbreviate both the comand and the type of object to be created (component in this case):</p> <pre><code>npx st c cp path/to/UserDataTable\n</code></pre> <p> In the above example, you'll be creating a component with name UserDataTable in the specified path, there is no need to create he folders and sub-folders, as in case they don't exist it'll get created.</p> </li> </ul> <p></p>"},{"location":"components/#11-component-requiredreserved-variables-reserved-for-the-framework","title":"1.1 Component required/reserved variables (Reserved for the Framework)","text":"<ul> <li> <p>isPublic - This states if the component can be accessed without authentication or not.</p> </li> <li> <p>template - Declares the UI itself by using differnt murkups (HTML, Still elements, Web-Component) and stylesheets (CSS). In case the template is defined in an HTML (see here) file then temlate variable should not exist in the component.</p> </li> </ul> <p>In adition to isPublic and template, there are other features which can be used inside the javaScript part of the component such as the special method/Hooks (see hooks section), follow an example:</p>  Project folder structureapp-setup.jsroute.map.jsUserForm.js Project folder structure<pre><code>project-root-folder\n|__ @still/\n|__ app/\n|    |\n|    |__ components/\n|    |   |__ user/\n|    |   |   |__ UserForm.js\n|    |   |   |\n|__ config/\n|    |__ app-setup.js\n|    |__ route.map.js\n|__  ...\n</code></pre> This is the where Application context aspects are setup. This file is in the root folder.<pre><code>import { StillAppMixin } from \"./@still/component/super/AppMixin.js\";\nimport { Components } from \"./@still/setup/components.js\";\nimport { AppTemplate } from \"./app-template.js\";\nimport { UserForm } from \"./app/components/user/UserForm.js\";\n\nexport class StillAppSetup extends StillAppMixin(Components) {\n\n    constructor() {\n        super();\n        //Defines the first component to load\n        this.setHomeComponent(UserForm);\n    }\n\n    async init() {\n        //Loads the app container and the initial component set at line 11\n        return await AppTemplate.newApp();\n    }\n\n}\n</code></pre> Routes will be added and manage automatically from here when creating the component using still-cli<pre><code>export const stillRoutesMap = {\n    viewRoutes: {\n        regular: {\n            UserForm: { path: \"app/components/user\", url: \"/user/create\" }\n        },\n        lazyInitial: {}\n    }\n}\n</code></pre> Defining the template<pre><code>import { ViewComponent } from \"../../../@still/component/super/ViewComponent.js\";\n\nexport class UserForm extends ViewComponent {\n\n    isPublic = true;\n\n     template = `\n        &lt;section&gt;\n            &lt;article&gt;\n                &lt;header&gt;This is my title&lt;/header&gt;\n                &lt;div&gt;\n                    My article content with relevant summary\n                &lt;/div&gt;\n                &lt;button&gt;Learn more&lt;/botton&gt;\n            &lt;/article&gt;\n        &lt;/section&gt;\n     `;\n}\n</code></pre> <p>The template (HTML) content will be display accordingly once the template as rendered. Again, template can also contain Web-component and/or Still component which would be a child component in this case.</p> <p></p>"},{"location":"components/#2-component-state-vs-property","title":"2. Component State vs Property","text":"<p>Those are 2 of the existing ways for the component to hold data, therefore, they serve different purpose, as State is reactive and takes affect on the component lifecycle, whereas Property does not. Follow the example:</p>  Project folder structureapp-setup.jsroute.map.jsUserForm.js Project folder structure<pre><code>project-root-folder\n|__ @still/\n|__ app/\n|    |\n|    |__ components/\n|    |   |__ user/\n|    |   |   |__ UserForm.js\n|    |   |   |\n|__ config/\n|    |__ app-setup.js\n|    |__ route.map.js\n|__  ...\n</code></pre> This is the where Application context aspects are setup. This file is in the root folder.<pre><code>import { StillAppMixin } from \"./@still/component/super/AppMixin.js\";\nimport { Components } from \"./@still/setup/components.js\";\nimport { AppTemplate } from \"./app-template.js\";\nimport { UserForm } from \"./app/components/user/UserForm.js\";\n\nexport class StillAppSetup extends StillAppMixin(Components) {\n\n    constructor() {\n        super();\n        //Defines the first component to load\n        this.setHomeComponent(UserForm);\n    }\n\n    async init() {\n        //Loads the app container and the initial component set at line 11\n        return await AppTemplate.newApp();\n    }\n\n}\n</code></pre> Routes will be added and manage automatically from here when creating the component using still-cli<pre><code>export const stillRoutesMap = {\n    viewRoutes: {\n        regular: {\n            UserForm: { path: \"app/components/user\", url: \"/user/create\" }\n        },\n        lazyInitial: {}\n    }\n}\n</code></pre> Defining Properties and States<pre><code>import { ViewComponent } from \"../../../@still/component/super/ViewComponent.js\";\n\nexport class UserForm extends ViewComponent {\n\n    isPublic = true;\n\n    /* Those states and have\n     * reactive feature/behavior */\n    firstName;\n    age;\n    gender;\n    department;\n\n    /* Those Property, they have to be annotated with @Prop and anotation\n     * ca be in the same or in a different line as the property itself */\n    /** @Prop */ \n    showCredentialsTab = false;\n\n    /** @Prop */ \n    myHtmlContainerId;\n\n    /** @Prop */ saveButtonLabl = 'Save User';\n\n    printUserFirstName(){\n        console.log(this.firstName.value);\n    }\n\n    assigneUserFirstName(newName){\n        this.firstName = newName;\n    }\n\n    printContainerId(){\n        console.log(this.myHtmlContainerId)\n    }\n\n}\n</code></pre> <p>When it comes to retrieve the value from a property we need to reference the <code>.velue</code> (line 25), but this is not the case for property (line 33). </p> <p>To listen to a State change reactively, some ways are provided, but more recurrent are binding it to the template, and subscribing to it as follows in the side code snippets:</p> <p>Listening to changes<pre><code>    // Via property binding in the template it automatically listen to changes reactively\n    template = `\n        &lt;div&gt;User Name: @firstName\n        &lt;button&gt; @saveButtonLabl &lt;/button&gt;\n    `;\n\n    // This is a Special method/Hook which can be declared in the component\n    stAfterInit(){\n        this.firstName.onChange(newValue =&gt; {\n            console.log(`User first name changed to ${newValue}`);\n        });\n    }\n</code></pre> A component can subscribe to itself just like any other component can as we see in the lines 8 to 10, therefore, a good place to declare subsription is in a Hook method like stAfterInit.</p> <p></p>"},{"location":"components/#3-nested-component","title":"3. Nested Component","text":"<p>It's possible to put one component inside another, nevertheless, in order to guarantee the better performance, Still.js only allow 2 levels of nested component as follow:</p>  Project folder structureapp-setup.jsroute.map.jsBiddingDisplay.jsBidOffersComponent.jsBiddersList.js Project folder structure<pre><code>project-root-folder\n|__ @still/\n|__ app/\n|    |\n|    |__ components/\n|    |   |__ bidding/\n|    |   |   |__ BiddingDisplay.js\n|    |   |   |__ BidOffersComponent.js\n|    |   |   |__ BiddersList.js\n|    |   |   |\n|__ config/\n|    |__ app-setup.js\n|    |__ route.map.js\n|__  ...\n</code></pre> Definition of the service folder<pre><code>import { StillAppMixin } from \"./@still/component/super/AppMixin.js\";\nimport { Components } from \"./@still/setup/components.js\";\nimport { AppTemplate } from \"./app-template.js\";\nimport { BiddingDisplay } from \"./app/components/bidding/BiddingDisplay.js\";\n\nexport class StillAppSetup extends StillAppMixin(Components) {\n\n    constructor() {\n        super();\n        this.setHomeComponent(BiddingDisplay);\n    }\n\n    async init() {\n        return await AppTemplate.newApp();\n    }\n\n}\n</code></pre> <pre><code>export const stillRoutesMap = {\n    viewRoutes: {\n        regular: {\n            BiddingDisplay: {\n                path: \"app/components/bidding\",\n                url: \"/bid/display\"\n            },\n            BidOffersComponent: {\n                path: \"app/components/bidding\",\n                url: \"/bid/offer\"\n            },\n            BiddersList: {\n                path: \"app/components/bidding\",\n                url: \"/bid/bidder\"\n            }\n        },\n        lazyInitial: {}\n    }\n}\n</code></pre> Parent Component<pre><code>import { ViewComponent } from \"../../../@still/component/super/ViewComponent.js\";\n\nexport class BiddingDisplay extends ViewComponent {\n\n    isPublic = true;\n    template = `\n        &lt;st-element component=\"BidOffersComponent\"&gt;&lt;/st-element&gt;\n        &lt;st-element component=\"BiddersList\"&gt;&lt;/st-element&gt;\n    `;\n\n}\n</code></pre> Child Component<pre><code>import { ViewComponent } from \"../../../@still/component/super/ViewComponent.js\";\n\nexport class BidOffersComponent extends ViewComponent {\n\n    isPublic = true;\n    template = `\n        Hhere I'll have my code which provide the UI output concerning\n        the offfers of the Bid.\n    `;\n\n}\n</code></pre> Another Child Component<pre><code>import { ViewComponent } from \"../../../@still/component/super/ViewComponent.js\";\n\nexport class BiddersList extends ViewComponent {\n\n    isPublic = true;\n    template = `\n        Here goes the list of bidders.\n    `;\n\n}\n</code></pre> <p>Above we have to parent component, which has one level of offsprings, additional level is not allowed using <code>&lt;st-element&gt;&lt;/st-element&gt;</code>, anyway it can be achieved by using Web-component or regular HTML. (see best preactices sectio).</p> <p>Nesting Component considerations</p> <p>Unlike Still.js component, Web-component and HTML tags are handled directly by the Browser, which means less burden and more performant UI, therefore, the concept in Still.js is that you have to design well the component and use &lt;st-element&gt;&lt;/st-element&gt; to handle the complex parts of your UI, and 3+ level of nested component for dealing with visual/formating aspects, this definitely will guarantee better performance.</p> <p></p> <p></p>"},{"location":"components/#4-component-to-component-communication","title":"4. Component to Component communication","text":"<p>Covering from the most basic to the most complex scenarios, Still.js provides wide different means of providing communication from component to component (e.g. Parent to child, Sibling to Sibling, any component to any other(s)). (see to the Component Communication for more details)</p> <p></p>"},{"location":"components/#41-parent-to-child-communication","title":"4.1 Parent to Child communication","text":"Project folder structureapp-setup.jsroute.map.jsBiddingDisplay.jsBidOffersComponent.js Project folder structure<pre><code>project-root-folder\n|__ @still/\n|__ app/\n|    |\n|    |__ components/\n|    |   |__ bidding/\n|    |   |   |__ BiddingDisplay.js\n|    |   |   |__ BidOffersComponent.js\n|    |   |   |\n|__ config/\n|    |__ app-setup.js\n|    |__ route.map.js\n|__  ...\n</code></pre> <pre><code>import { StillAppMixin } from \"./@still/component/super/AppMixin.js\";\nimport { Components } from \"./@still/setup/components.js\";\nimport { AppTemplate } from \"./app-template.js\";\nimport { BiddingDisplay } from \"./app/components/bidding/BiddingDisplay.js\";\n\nexport class StillAppSetup extends StillAppMixin(Components) {\n\n    constructor() {\n        super();\n        this.setHomeComponent(BiddingDisplay);\n    }\n\n    async init() {\n        return await AppTemplate.newApp();\n    }\n\n}\n</code></pre> <pre><code>export const stillRoutesMap = {\n    viewRoutes: {\n        regular: {\n            BiddingDisplay: {\n                path: \"app/components/bidding\",\n                url: \"/bid/display\"\n            },\n            BidOffersComponent: {\n                path: \"app/components/bidding\",\n                url: \"/bid/offer\"\n            },\n        },\n        lazyInitial: {}\n    }\n}\n</code></pre> Parent Component<pre><code>import { ViewComponent } from \"../../../@still/component/super/ViewComponent.js\";\n\nexport class BiddingDisplay extends ViewComponent {\n\n    isPublic = true;\n\n    template = `\n        &lt;st-element \n            component=\"BidOffersComponent\"\n            hieghestOffer=\"30\"\n            leadBidderName=\"Gregor\"\n        &gt;&lt;/st-element&gt;\n    `;\n}\n</code></pre> Child Component called inside BiddingDisplay<pre><code>import { ViewComponent } from \"../../../@still/component/super/ViewComponent.js\";\n\nexport class BidOffersComponent extends ViewComponent {\n\n    isPublic = true;\n\n    hieghestOffer = 0;\n    leadBidderName = null;\n\n    template = `\n        &lt;span&gt;Hier Offer&lt;/span&gt; @hieghestOffer\n        &lt;span&gt;The leading Bidder is @leadBidderName&lt;/span&gt;\n    `;\n\n}\n</code></pre> <p>Parent component is passing 2 (hieghestOffer, leadBidderName) properties  when referencing the child, those are states variables in the child whichwill be overriden.</p> <p>Just like it's possible to update child state by passing if as property in <code>&lt;st-element&gt;</code> tag, we can also pass method as follow:</p> BiddingDisplay.jsBidOffersComponent.js Parent Component<pre><code>import { ViewComponent } from \"../../../@still/component/super/ViewComponent.js\";\n\nexport class BiddingDisplay extends ViewComponent {\n\n    isPublic = true;\n\n    template = `\n        &lt;st-element \n            component=\"BidOffersComponent\"\n            hieghestOffer=\"30\"\n            leadBidderName=\"Gregor\"\n            (myMethodSignature)=\"alertMyChild()\"\n        &gt;&lt;/st-element&gt;\n    `;\n\n    alertMyChild(){\n        alert('Hello my child')\n    }\n}\n</code></pre> Child Component<pre><code>import { ViewComponent } from \"../../../@still/component/super/ViewComponent.js\";\n\nexport class BidOffersComponent extends ViewComponent {\n\n    isPublic = true;\n\n    hieghestOffer = 0;\n    leadBidderName = null;\n\n    template = `\n        &lt;span&gt;Hier Offer&lt;/span&gt; @hieghestOffer\n        &lt;span&gt;The leading Bidder is @leadBidderName&lt;/span&gt;\n        &lt;button (click)=\"myMethodSignature()\"&gt;Call Parent Function&lt;/button&gt;\n    `;\n\n\n    myMethodSignature(){}\n\n}\n</code></pre> <p>Unlike state and property variables, method on the <code>&lt;st-element&gt;</code> component need to be references in paranthesis (), also, normally in the child we'll have the method signature, nevertheless we can also have it's own scope.</p> <p>It's also possible for the child to pass values to parent when executing method signature, follow the example:</p> BiddingDisplay.jsBidOffersComponent.js Parent Component<pre><code>import { ViewComponent } from \"../../../@still/component/super/ViewComponent.js\";\n\nexport class BiddingDisplay extends ViewComponent {\n\n    isPublic = true;\n\n    template = `\n        &lt;st-element \n            (processMyData)=\"alertMyChild()\"\n        &gt;&lt;/st-element&gt;\n    `;\n\n    printChildDetailes(age, name){\n        console.log(`Hello ${name} you're ${age} years old!`)\n    }\n}\n</code></pre> <p>```js title=\"Child Component\" hl_lines=\"8 13\" linenums=\"1\" import { ViewComponent } from \"../../../@still/component/super/ViewComponent.js\";</p> <p>export class BidOffersComponent extends ViewComponent {</p> <pre><code>isPublic = true;\n\ntemplate = `\n    &lt;button (click)=\"processMyData(30, 'John')\"&gt;\n        Call Parent Function\n    &lt;/button&gt;\n`;\n\nmyMethodSignature(age, name){}\n</code></pre> <p>}</p> <p>In addition to using <code>&lt;st-element&gt;</code> component props, there are other means available for component to component communication such as <code>Pub/Sub</code>, both <code>@Proxy</code> and <code>ref</code> which is done to through <code>&lt;st-element&gt;</code> again, and the <code>Service</code> which is a global kind. (see to the Component Communication).</p> <p></p> <p>Embieding component in your regular HTML or within other Frameworks</p> <p>When it comes to components, Still.js provides the Lone Component which only require to reference the CDN for both CSS and JavaScript files thereby not needing to create a Still.js project, therefore, this approach can be followed either for small use case as well as for complex ones such as Microfrontend. (follow do documentation here)</p> <p> </p>"},{"location":"conditional-rendering/","title":"CONDITIONAL RENDERING, SHOW/HIDE","text":""},{"location":"conditional-rendering/#overview","title":"Overview","text":"<p>When it comes to handle specific part of a component/UI in order to hide/unhide or render conditionally, Stilljs provides with a proper directive.</p>"},{"location":"conditional-rendering/#the-showif-showif-directive-example","title":"The <code>(showIf) - showIf</code> Directive example:","text":"<p>As the directive itself suggests, this directive will <code>show</code> a content <code>If</code> the assigned flag matches the stated condition, in case the condition is not matched, it'll hide the content.</p> <p>It's mandatory to specify the container (see container directive) when using <code>(showIf)</code> directive, and, in the container itself, we place our condition as follow bellow:</p> templatecomponent This is the template code snippet<pre><code>&lt;div&gt;\n    &lt;p&gt;\n        Click to hide/unhide the date\n    &lt;/p&gt;\n    &lt;button (click)=\"handleShowDate()\"&gt;Hide/Unhide date&lt;/button&gt;\n    &lt;div (showIf)=\"self.showDate\"&gt;\n        Today is @todayDate\n    &lt;/div&gt;\n&lt;/div&gt;\n</code></pre> This is the component code snippet<pre><code>// Because we don't need to listen to changes, the variable is turned to Prop\n/** @Prop */\ntodayDate = new Date().toDateString();\n\n/** @Prop */\nshowDate = true;\n\nhandleShowDate() {\n    this.showDate = !this.showDate;\n}\n</code></pre> <p>In the above example, the flag need to be boolean, in this case it will be checked that if it's true, then the data will be showed, otherise (if false), it'll hidden. </p> <p>It's also possible to negate the <code>(showIf)</code> - renderIf flag by putting ! before the flag itself, if that's the case we'll have the code as follow:</p> <pre><code>&lt;div (showIf)=\"!self.showDate\"&gt;\n</code></pre> <p></p>"},{"location":"conditional-rendering/#using-expresion-as-flag","title":"Using expresion as flag","text":"<p>It's also possible to use expression when using the <code>(renderIf)</code> directive, for that, the expression needs to produce a boolean result as follow:</p> templatecomponent This is the template code snippet<pre><code>&lt;div&gt;\n    &lt;nav&gt;\n        &lt;div&gt;\n            &lt;button (click)=\"showOption(2)\"&gt;2&lt;/button&gt;\n            &lt;button (click)=\"showOption(3)\"&gt;3&lt;/button&gt;\n            &lt;button (click)=\"showOption(5)\"&gt;5&lt;/button&gt;\n        &lt;/div&gt;\n    &lt;/nav&gt;\n    &lt;p&gt;The bellow content is presente acoordng to the flag assigned value&lt;/p&gt;\n    &lt;div (showIf)=\"self.checkFlag==5\"&gt;Contante when flag is 5&lt;/div&gt;\n    &lt;div (showIf)=\"self.checkFlag==3\"&gt;Whrn flag is 3 this is the content&lt;/div&gt;\n    &lt;div (showIf)=\"self.checkFlag==2\"&gt;Flag value was assigned with 2&lt;/div&gt;\n&lt;/div&gt;\n</code></pre> This is the component code snippet<pre><code>/** @Prop */\nisMainFlag = true;\n\n/** @Prop */\ncheckFlag;\n\n// Set the initial value for checkFlag  \n// when the component got initiated\nstAfterInit(){\n    this.checkFlag = 3;\n}\n\nshowOption(val){\n    this.checkFlag = val;\n}\n</code></pre> <p></p>"},{"location":"conditional-rendering/#the-renderif-directive-example","title":"The <code>(renderIf)</code> Directive example:","text":"<p>The <code>(renderIf)</code> directive will not render the UI part if the flag value is false, whereas <code>(showIf)</code> hides only giving the possibility of unhiding it afterwards.</p> <p>Unlike <code>(showIf)</code>, the <code>(renderIf)</code> is flaged with a boolean only, means, expressions kind of flagging is not supported.</p> <p></p>"},{"location":"directive/","title":"TEMPLATE DIRECTIVE","text":""},{"location":"directive/#overview","title":"Overview","text":"<p>Directives is a way in Still.js to deal with some UI specific features on the template side of things, which also provides capabilities to handle DOM tree and elements eliminating the need for diracte manipulating it in some specific situations.</p> <p>In Still.js, directives are added as HTML tag properties enclosed in parentheses (e.g., (click)), visually distinguishing them from standard HTML attributes.</p> <p>There are some directives available, and they are addressing things in different categories such as <code>event binding</code>, <code>form binding</code>, <code>looping</code>, <code>rendering</code> &amp; <code>conditional</code>, <code>form validation</code>, follow a list bellow:</p>"},{"location":"directive/#event-directive","title":"Event Directive","text":"<p>Those directives allow to tie specific kind of event to HTML form input by specifying the component method to be called, follow the list: </p> Directive Applicable to Description Use context (click) Any HTML element/tag It adds the click event to the target element by providing access to the component methods. <ul> <li>Any event click implementation calling component method</li> </ul> (change) HTML &lt;select&gt;/combobox element It binds a component method to a combo-box allowing detect change on it. <ul> <li>Any event click implementation calling component method</li> </ul> <p></p>"},{"location":"directive/#the-click-directive-example","title":"The <code>(click)</code> Directive example:","text":"<p>Click event binding considering a component implemented method.</p> templatecomponent This is the template code snippet<pre><code>&lt;button (click)=\"increment()\"&gt;count-state (@countVariable) +&lt;/button&gt;\n&lt;button (click)=\"decrement()\"&gt;count-state (@countVariable) -&lt;/button&gt;\n</code></pre> This is the component code snippet<pre><code>countVariable = 0;\n\n// This is going to be bound to the template via (click) directive\nincrement(){\n    this.countVariable = this.countVariable.value + 1;\n}\n\n// This is going to be bound to the template via (click) directive\ndecrement(){\n    this.countVariable = this.countVariable.value - 1;\n}\n</code></pre> <p> </p>"},{"location":"directive/#the-change-directive-example","title":"The <code>(change)</code> Directive example:","text":"<p>Change event binding for HTML &lt;select&gt; tag/combobox ti check whenever a value gets selected.</p> templatecomponent This is the template code snippet<pre><code>&lt;form&gt;\n    &lt;select (change)=\"callIfChanging($event)\"&gt;\n        &lt;option value=\"\"&gt;Select the country&lt;/option&gt;\n        &lt;option value=\"1\"&gt;Austria&lt;/option&gt;\n        &lt;option value=\"2\"&gt;Bulgaria&lt;/option&gt;\n        &lt;option value=\"3\"&gt;Canada&lt;/option&gt;\n    &lt;/select&gt;\n&lt;/form&gt;\n</code></pre> This is the component code snippet<pre><code>// This is going to be bound to the template via (change) directive\ncallIfChanging(e) {\n    console.log(`Country selected value is: `, e.target.value);\n\n}\n</code></pre> <p>Changes in the regular HTML input can be handled through the state change in the bound state as shown in the (value) directive example.</p> <p>Event Binding considerations</p> <p>In general, Still.js concerns especially with click event not to miss the capability to bind component methods, anyway, therefore, when it comes to other events (except for onchange for combobox) the approach to follow is regular DOM manipulation and JavaScript since Still.js is pure javaScript.</p> <p> </p>"},{"location":"directive/#container-directives","title":"Container Directives","text":"<p>Those directives are placed in any HTML element that can enclose other elements thereby providing features like looping through a list, rendering/not rendering, hide/unhide:</p> Directive Applicable to Description Use context (forEach) Any HTML wrapper elemen (e.g. &lt;div&gt;, &lt;section&gt;, &lt;span&gt;, &lt;select&gt;, etc.) Allow looping through a list of elements while printing each element in the UI. <ul> <li>Generating data for Datatable</li> <li>Looping to a list for a combobox</li> <li>Mapping a list to cards</li> <li>etc.</li> </ul> (renderIf) Any HTML wrapper elemen (e.g. &lt;div&gt;, &lt;section&gt;, &lt;span&gt;, &lt;select&gt;, etc.) Render/Not render an element according to a flag value (true/false) <ul> <li>Prevent application part/section not to render</li> <li>Suitable for user permission content render manipulation</li> </ul> (showIf) Any HTML wrapper elemen (e.g. &lt;div&gt;, &lt;section&gt;, &lt;span&gt;, &lt;select&gt;, etc.) Hide/Unhide render an element according to a flag value (true/false) <ul> <li>Hide/Unhide UI part according to business rules.</li> </ul> <p></p>"},{"location":"directive/#the-foreach-directive-example","title":"The <code>(forEach)</code> Directive example:","text":"<p>It loops through a list/array of any type of element allowing the maping of it to some kind of desirable output.</p> templatecomponent This is the template code snippet<pre><code>&lt;!-- Outermost container --&gt;\n&lt;div&gt;\n    &lt;!-- Looping container --&gt;\n    &lt;span (forEach)=\"frutList\"&gt;\n        &lt;div each=\"item\"&gt;\n            Fruit: {item.name} | Color: {item.color}\n        &lt;/div&gt;\n    &lt;/span&gt;\n&lt;/div&gt;\n</code></pre> This is the component code snippet<pre><code>// This is a state variable in the componet with an array of objects\nfrutList = [\n    { name: 'Banana', color: 'yellow' },\n    { name: 'Apple', color: 'red' },\n    { name: 'Grapes', color: 'violet' },\n]\n</code></pre> <p>Result:</p> <p></p> <p> </p>"},{"location":"directive/#the-renderif-directive-example","title":"The <code>(renderIf)</code> Directive example:","text":"<p>This comes into place especially in it comes to handle parts of the App that can or cannot render according to the user permission, if it does not reneders, it woun't even in the DOM tree.</p> templatecomponent This is the template code snippet<pre><code>&lt;div&gt;\n    This is a regular content which does not require permision\n    &lt;div (renderIf)=\"self.isUserAdmin\"&gt;\n        This requires user permission to render\n    &lt;/div&gt;\n&lt;/div&gt;\n</code></pre> This is the component code snippet<pre><code>// Flag needs to be component prop, hence they're annotated with it\n/** @Prop */ \nisUserAdmin = false;\n</code></pre> <p>(renderIf) works with flag, which true will make it to render, and false not. The flag is defined in the component itself and needs to be annotated with <code>@Prop</code> annotation. When referencing the flag variable it's required to use the <code>self.</code> prefix.</p> <p> </p>"},{"location":"directive/#the-showif-directive-example","title":"The <code>(showIf)</code> Directive example:","text":"<p>In contrast to (renderIf), the (showIf) is to be used if we still need to render the UI/component part but keep it hidden.</p> templatecomponent This is the template code snippet<pre><code>&lt;div&gt;\n    &lt;p&gt;\n        Click to hide/unhide the date\n    &lt;/p&gt;\n    &lt;button (click)=\"handleShowDate()\"&gt;Hide/Unhide date&lt;/button&gt;\n    &lt;div (showIf)=\"self.shouldShowDate\"&gt;\n        Today is @todayDate\n    &lt;/div&gt;\n&lt;/div&gt;\n</code></pre> This is the component code snippet<pre><code>// Because we don't need to listen to changes, the variable is turned to Prop\n/** @Prop */\ntodayDate = new Date().toDateString();\n\n/** @Prop */\nshouldShowDate = true;\n\nhandleShowDate() {\n    this.shouldShowDate = !this.shouldShowDate;\n}\n</code></pre> <p>(renderIf) works with flag, which true will make it to render, and false not. The flag is defined in the component itself and needs to be annotated with <code>@Prop</code> annotation. When referencing the flag variable it's required to use the <code>self.</code> prefix.</p> <p>Animated result:</p> <p></p> <p></p>"},{"location":"directive/#form-binding-directives","title":"Form Binding Directives","text":"<p>Directives in the Form binding category allows to handle 2-way binding as wey as handle validation as needed when dealing with form submit, follow hte list:</p> Directive Applicable to Description Use context (formRef)                              dependent                 Depends on validator directives: (required) or (validator) HTML form/form tag Privides a form referance variable to allow handling form validation, however, only makes sense if validation is in place <ul> <li>Form validation on submit</li> </ul> (value) HTML form input element (e.g. &lt;input&gt;, &lt;select&gt;, except for radio and checkbox, as thier bind is done with (field) directive instead) Provides two-way binding for a form input against a component state <ul> <li>Two-way between component state variable and a Form input.</li> <li>On the Radio button and Checkbox only serves to bind value, but not property.</li> </ul> (field) HTML form, Radio button and Checkboxes Provides two-way binding for a form input against a component state <ul> <li>Two-way between component state variable and a Form Radiobutton and/or Checkbox input</li> </ul> (labelAfter) Radio button and Checkboxes text label Puts the specified text label right after (beside) the Radiobutton/Checkbox <ul> <li>Presenting label to the used</li> </ul> (labelBefore) Radio button and Checkboxes text label Puts the specified text label right before (beside) the Radiobutton/Checkbox <ul> <li>Presenting label to the used</li> </ul> <p></p> <p></p>"},{"location":"directive/#the-formref-directive-example","title":"The <code>(formRef)</code> Directive example:","text":"<p>For <code>(formRef)</code> to be effective, form inputs must use validation directives, be bound to component state variables via <code>(value)</code>, and include either <code>(required)</code> and/or <code>(validator)</code> directives to enable validation.</p> templatecomponent This is the template code snippet<pre><code>&lt;div&gt;\n    &lt;!-- formRef is a variable inside the component --&gt;\n    &lt;form (formRef)=\"myForm\"&gt;\n        &lt;!-- Both (value) and (required) are present and mantadory for validation --&gt;\n        &lt;select (required)=\"true\" (value)=\"myCountry\"&gt;\n            &lt;option value=\"\"&gt;Select the country&lt;/option&gt;\n            &lt;option value=\"1\"&gt;Austria&lt;/option&gt;\n            &lt;option value=\"2\"&gt;Bulgaria&lt;/option&gt;\n            &lt;option value=\"3\"&gt;Canada&lt;/option&gt;\n        &lt;/select&gt;\n        &lt;!-- Both (value) and (required) are present and mantadory for validation --&gt;\n        &lt;input type=\"text\" (value)=\"myField\" (required)=\"true\"&gt;\n    &lt;/form&gt;\n    &lt;!-- sendForm() method will use the (formRef) to check validation --&gt;\n    &lt;button (click)=\"sendForm()\"&gt;Submit Form&lt;/button&gt;\n&lt;/div&gt;\n</code></pre> This is the component code snippet<pre><code>//Because we don't need to listen to changes we're turning form-ref to Prop\n/** @Prop  */\nmyForm;\n//This state is bound to form combobox\nmyCountry;\n//This state is bound to form input\nmyField;\n//This state is bound the template\nsubmissionResult = `Fill the form`;\n\nsendForm() {\n    //Validate method runs and returns validation result\n    const isValid = this.myForm.validate();\n    if (isValid) {\n        this.submissionResult = `\n            &lt;span style=\"color: green;\"&gt;\n                Form subitted successfully.\n            &lt;/span&gt;\n        `;\n    }\n}\n</code></pre> <p>At the end of the day, the validation variable which is assigned to the <code>(formRef)</code> then is provided with <code>validate()</code> method among others, when it gets call, if all validations are passing it'll return true, otherwise it's false, see the result:</p> <p>Animated result:</p> <p></p> <p> </p>"},{"location":"directive/#the-value-directive-example","title":"The <code>(value)</code> Directive example:","text":"<p>In addition to be a complement for the <code>(formRef)</code> when it comes to validation, <code>(value)</code> directive allows 2-way biding with component state variables.</p> templatecomponent This is the template code snippet<pre><code>&lt;div style=\"padding: 10px;\"&gt;\n    &lt;form&gt;\n        &lt;select (value)=\"myCountry\"&gt;\n            &lt;option value=\"\"&gt;Select the country&lt;/option&gt;\n            &lt;option value=\"Austria\"&gt;Austria&lt;/option&gt;\n            &lt;option value=\"Bulgaria\"&gt;Bulgaria&lt;/option&gt;\n        &lt;/select&gt;\n        &lt;input type=\"text\" (value)=\"myField\"&gt;\n    &lt;/form&gt;\n    &lt;p&gt;&lt;b&gt;Selected country:&lt;/b&gt; @myCountry&lt;/p&gt;\n    &lt;p&gt;&lt;b&gt;My Field value:&lt;/b&gt; @myField&lt;/p&gt;\n    &lt;button (click)=\"autoFill()\"&gt;Auto-fill the form&lt;/button&gt;\n    &lt;button (click)=\"emptyCountry()\"&gt;Clear Country&lt;/button&gt;\n&lt;/div&gt;\n</code></pre> This is the component code snippet<pre><code>// We need to listen to changes of both, hence they're state (not @Prop annotated)\nmyCountry = '';\nmyField = '';\n\nautoFill() {\n    this.myCountry = 'Bulgaria';\n    this.myField = 'Default value';\n}\n\nemptyCountry() {\n    this.myCountry = '';\n}\n</code></pre> <p>(renderIf) works with flag, which true will make it to render, and false not. The flag is defined in the component itself and needs to be annotated with <code>@Prop</code> annotation. When referencing the flag variable it's required to use the <code>self.</code> prefix.</p> <p>Animated result:</p> <p></p> <p> </p> <p></p>"},{"location":"directive/#form-validation-directives","title":"Form Validation Directives","text":"<p>Validation Directives make it quite easy to handle validation in Still.js very few lines where only the directive concerning the specific validation needs to be used, follow hte list:</p> Directive Applicable to Description Use context (required) HTML form input element (e.g. &lt;input&gt;, &lt;select&gt;) Mark a form elemen as required which gets triggered when validation checked through (formRef) <ul> <li>Form validation on submit</li> </ul> (validator) HTML &lt;input&gt; tag Specify of valid data type for an input field <ul> <li>Hide/Unhide UI part according to business rules.</li> </ul>              (validator-max)                               dependent                 Depends (validator) HTML numeric &lt;input&gt; tag Specify the max value allowed in the field <ul> <li>Limit the maximun numeric threshold.</li> </ul>              (validator-max-warn)                               dependent                 Depends (validator) HTML numeric &lt;input&gt; tag Specify message to display if max allowed value is violeted <ul> <li>Customize max limit warning message.</li> </ul>              (validator-min)                               dependent                 Depends (validator) HTML numeric &lt;input&gt; tag Specify the min value allowed in the field <ul> <li>Limit the minimun numeric threshold.</li> </ul>              (validator-min-warn)                               dependent                 Depends (validator) HTML numeric &lt;input&gt; tag Specify message to display if min allowed value is violeted <ul> <li>Customize min limit warning message.</li> </ul>              (validator-trigger)                               dependent                 Depends (validator) HTML &lt;input&gt; tag Specify (validator) should trigger (e.g. when typing, when focus, when blur) <ul> <li>Customize min limit warning message.</li> </ul> <p></p>"},{"location":"directive/#the-required-directive-example","title":"The <code>(required)</code> Directive example:","text":"<p>It defines the HTML form field/input element as mandatory thereby making it marked for validation, therefore, proper validation requires the form to have a reference (see this example), and validation is verified through it.</p> <p></p>"},{"location":"directive/#the-validator-directive-example","title":"The <code>(validator)</code> Directive example:","text":"<p>This directive works with <code>(value)</code> to define valid input types for form elements. Still.js offers 7 default validators, and custom validators can also be implemented. </p> <p>Follow the built-in Validators:</p> <ul> <li>number - Allow only number in the target filed</li> <li>alphanumeric - Allow both number and text but not special characters</li> <li>text - Allow anything</li> <li>email - Allow email only</li> <li>phone - Allow Telephone number format</li> <li>date - Allow data</li> <li>dateUS - Allow date in USA format</li> </ul> <p> </p>"},{"location":"directive/#using-a-validator","title":"Using a validator","text":"<p>To use it we only need to assign its name to the directive (e.g. <code>(validator)=\"number\"</code>) hence, every name has to be unique.</p> templatecomponent This is the template code snippet<pre><code>&lt;div style=\"padding: 10px;\"&gt;\n    &lt;form&gt;\n        &lt;div class=\"input-group\"&gt;\n            &lt;label for=\"\"&gt;Country:&lt;/label&gt;\n            &lt;select \n                (validator)=\"text\"\n                (value)=\"myCountry\" \n            &gt;\n                &lt;option value=\"\"&gt;Select the country&lt;/option&gt;\n                &lt;option value=\"Austria\"&gt;Austria&lt;/option&gt;\n                &lt;option value=\"Bulgaria\"&gt;Bulgaria&lt;/option&gt;\n            &lt;/select&gt;\n        &lt;/div&gt;\n        &lt;div class=\"input-group\"&gt;\n            &lt;label for=\"\"&gt;Shoe Size:&lt;/label&gt;\n            &lt;input \n                (value)=\"shoeSize\" \n                (validator)=\"number\" \n                placeholder=\"Type the shoe size\"\n            &gt;\n        &lt;/div&gt;\n    &lt;/form&gt;\n&lt;/div&gt;\n</code></pre> This is the component code snippet<pre><code>// We only need the state variable that are bound to the form inputs\nmyCountry = '';\nshoeSize;\n</code></pre> <p>Animated result:</p> <p></p> <p>When used in an input text field, unless we override the trigger (by defining <code>(validator-trigger)</code> directive) the validation happens as  we type the value. When it comes to combo-box, the validator only takes affect through the <code>(formRef)</code> by calling <code>.validate()</code> as in this example.</p> <p> </p>"},{"location":"directive/#implementing-custom-validator","title":"Implementing Custom Validator","text":"<p>Custom validators are typically added at the application level in <code>StillAppSetup</code> (<code>app-setup.js</code>). However, they can also be registered elsewhere, like directly within a component, using the <code>.addValidator()</code> utility method.</p> templatecomponentapp-setup.js Custom validator - first 2 are implemented inside the AppSetup, the last one is in the component itself<pre><code>&lt;div style=\"padding: 10px;\"&gt;\n    &lt;form&gt;\n        &lt;div class=\"input-group\"&gt;\n            &lt;label for=\"\"&gt;Shoe Size:&lt;/label&gt;\n            &lt;input \n                (value)=\"shoeSize\" \n                (validator)=\"twoNumberOnly\" \n                placeholder=\"Type the shoe size\"&gt;\n        &lt;/div&gt;\n        &lt;div class=\"input-group\"&gt;\n            &lt;label for=\"\"&gt;Car Speed capacity:&lt;/label&gt;\n            &lt;input \n                (value)=\"speedCapacity\" \n                (validator)=\"max3Chars\" \n                placeholder=\"Type cad speed limit\"&gt;\n        &lt;/div&gt;\n        &lt;!-- \n         The above validators are implemented in the StillAppSetup, \n         whereas the bellow one is in the component \n        --&gt;\n        &lt;div class=\"input-group\"&gt;\n            &lt;label for=\"\"&gt;Name prefix:&lt;/label&gt;\n            &lt;input \n                (value)=\"namePrefix\" \n                (validator)=\"prefixValidator\" \n                placeholder=\"Type you name prefix\"&gt;\n        &lt;/div&gt;\n    &lt;/form&gt;\n&lt;/div&gt;\n</code></pre> This is the component code snippet<pre><code>// The states that are bound to the form\nshoeSize;\nspeedCapacity;\nnamePrefix;\n\nstOnRender() {\n    // A custom validator added before the component is rendered\n    StillAppSetup.addValidator('prefixValidator', (value) =&gt; {\n        if (value === 'First-' || value === 'Sec-')\n            return true;\n        return false;\n    });\n}\n</code></pre> This is the component code snippet<pre><code>import { StillAppMixin } from \"./@still/component/super/AppMixin.js\";\nimport { Components } from \"./@still/setup/components.js\";\nimport { AppTemplate } from \"./app-template.js\";\nimport { HomeComponent } from \"./app/home/HomeComponent.js\";\n\nexport class StillAppSetup extends StillAppMixin(Components) {\n\n    constructor() {\n        super();\n        this.setHomeComponent(HomeComponent);\n\n        //This is a regular expression type of validaor \n        this.addValidator('twoNumberOnly', /^[0-9]{2}$/);\n\n        //This is a function type of validaor\n        this.addValidator('max3Chars', (val) =&gt; {\n            return val.length &gt;= 1 &amp;&amp; val.length &lt;= 3;\n        });\n\n    }\n\n    async init() {\n        return await AppTemplate.newApp();\n    }\n\n}\n</code></pre> <p>Animated result:</p> <p></p> <p> </p>"},{"location":"directive/#the-validator-trigger-directive","title":"The <code>(validator-trigger)</code> directive","text":"<p>This state when the validation will happen if <code>(required)</code> and/or <code>(validator)</code> is/are defined, therefore, there are 3 type as follow:</p> <ul> <li>typing - Default for input text, it makes the validation to trigger as we're typing.</li> <li>losefocus - Check validation when the cursor is moved out from the target input.</li> <li>focus - Checks validation when the cursor is placed inside the target input.</li> </ul> <p></p>"},{"location":"form/","title":"FORM & VALIDATION","text":""},{"location":"form/#overview","title":"Overview","text":"<ul> <li>As known, form are one of the most ways and traditional user inputs approaches, hence, in Still.js they are part of the core features.</li> </ul>"},{"location":"form/#what-youll-learn","title":"What you'll learn","text":"<p> \u00a0\u00a0\u00a0 Two-way input Binding considering   \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 text,       \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 radio-button,       \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 check-box,      \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 and Combobox (select)</p> <p></p> <p> \u00a0\u00a0\u00a0 Validators </p> <p></p>"},{"location":"form/#the-html-form-tag-in-form-declaration","title":"The HTML Form tag in form Declaration","text":"<ul> <li>In Still.js, when creating a form it's required to wrap all components within the <code>&lt;form&gt;</code> HTML tags, otherwise it won't work or it'll misbehave. Follow an example bellow:</li> </ul>"},{"location":"form/#binding-input-text","title":"Binding input text","text":"Person.html - templatePerson.js - component Because the HTML file as the same name it's automatically bound to the .js as template.<pre><code>&lt;div&gt;Hello @firstName @lastName&lt;/div&gt;\n&lt;form&gt;\n    &lt;div&gt;\n        &lt;label&gt;First name:&lt;/label&gt;\n        &lt;input (value)=\"firstName\" placeholder=\"Enter your firstname\"&gt;\n    &lt;/div&gt;\n    &lt;div&gt;\n        &lt;label&gt;Last name:&lt;/label&gt;\n        &lt;input (value)=\"lastName\" placeholder=\"Enter your lastname\"&gt;\n    &lt;/div&gt;\n&lt;/form&gt;\n</code></pre> <pre><code>import { ViewComponent } from \"../../@still/component/super/ViewComponent.js\";\n\nexport class Person extends ViewComponent {\n\n    isPublic = true;\n\n    firstName;\n    lastName;\n\n}\n</code></pre> <p>The form has two fields, First Name and Last Name, whose values are bound to the component's <code>firstName</code> and <code>lastName</code> state variables using the (value) directive. Also, they're bound to the tempate in the <code>Hello @firstName @lastName</code> statement.</p> <p>Still.js supports 2-way binding, so changes to bound input fields automatically update the linked state variables and keep the UI reactive.</p> <p></p>"},{"location":"form/#binding-radio-button-andor-checkbox","title":"Binding Radio Button and/or Checkbox","text":"Person.html - templatePerson.js - component Because the HTML file as the same name it's automatically bound to the .js as template.<pre><code>&lt;div&gt;Hello @firstName @lastName&lt;/div&gt;\n&lt;form&gt;\n    &lt;!-- First and Last name inputs above --&gt;\n    &lt;div&gt;\n        &lt;label&gt;Gender:&lt;/label&gt;\n        &lt;input type=\"radio\" (value)=\"M\" (labelAfter)=\"M\" (field)=\"gender\"&gt;\n        &lt;input type=\"radio\" (value)=\"F\" (labelAfter)=\"F\" (field)=\"gender\"&gt;\n    &lt;/div&gt;\n    &lt;div&gt;\n        &lt;label&gt;Skills:&lt;/label&gt;\n        &lt;span (forEach)=\"skills\"&gt;\n            &lt;input \n                each=\"item\" \n                type=\"checkbox\" \n                (labelAfter)=\"{item.name}\" \n                (field)=\"selectedSkills\" \n                (value)=\"{item.id}\"&gt;\n        &lt;/span&gt;\n    &lt;/div&gt;\n    &lt;div&gt;\n        &lt;label&gt;Role:&lt;/label&gt;\n        &lt;span (forEach)=\"roles\"&gt;\n            &lt;input each=\"item\" \n                type=\"radio\" \n                (labelAfter)=\"{item.name}\" \n                (field)=\"selectedRole\" \n                (value)=\"{item.id}\"&gt;\n        &lt;/span&gt; \n    &lt;/div&gt;\n&lt;/form&gt;\n</code></pre> <pre><code>import { ViewComponent } from \"../../@still/component/super/ViewComponent.js\";\n\nexport class Person extends ViewComponent {\n\n    isPublic = true;\n\n    firstName = '';\n    lastName = '';\n    selectedSkills;\n    selectedRole;\n\n    skills = [\n        {id: 1, name: 'Finance'}, \n        {id: 2, name: 'Human Resource'}, \n        {id: 3, name: 'Marketing'}\n    ]\n\n    roles = [\n        {id: 1, name: 'Manager'}, \n        {id: 3, name: 'Director'}, \n    ]\n\n}\n</code></pre> <p>Two scenarios are being addressed in the template, we have the gender field with hard coded values, whereas Stills and Role fields are coming from lists and we're looping throug them.</p> <p>Whereas input text and comboboxes bind is done via <code>(value)</code>, for Radio and Checkbox we use <code>(field)</code> while <code>(value)</code> is still used for the value itself instead for binding. <code>(value)</code> in the combo-box holds the actual value instead of the component binding variable.</p> <p>Checkboxes and radio buttons in Still.js use a <code>label</code> directive with position suffixes like <code>Before</code> or <code>After</code> to control label placement relative to the input.</p> <p></p>"},{"location":"form/#binding-combobox-select","title":"Binding Combobox (select)","text":"Person.html - templatePerson.js - component Because the HTML file as the same name it's automatically bound to the .js as template.<pre><code>&lt;div&gt;Hello @firstName @lastName&lt;/div&gt;\n&lt;form&gt;\n    &lt;!-- First and Last name inputs above... --&gt;\n    &lt;!-- Radio buttons and check boxes binding above... --&gt;\n    &lt;div&gt;\n        &lt;label&gt;Hobbies:&lt;/label&gt;\n        &lt;select \n            (forEach)=\"hobbiesList\" \n            (value)=\"preferedHobby\" \n            placeholder=\"Select prefered hobby\"&gt;\n            &lt;option each=\"item\" value=\"{item.code}\"&gt;{item.name}&lt;/option&gt;\n        &lt;/select&gt;   \n    &lt;/div&gt;\n    &lt;div&gt;\n        &lt;label&gt;Is adult?&lt;/label&gt;\n        &lt;select (value)=\"isPersonAdult\"&gt;\n            &lt;option value=\"\"&gt;Select an option&lt;/option&gt;\n            &lt;option value=\"1\"&gt;Yes&lt;/option&gt;\n            &lt;option value=\"0\"&gt;No&lt;/option&gt;\n        &lt;/select&gt;   \n    &lt;/div&gt;\n&lt;/form&gt;\n</code></pre> <pre><code>import { ViewComponent } from \"../../@still/component/super/ViewComponent.js\";\n\nexport class Person extends ViewComponent {\n\n    firstName = '';\n    lastName = '';\n    selectedSkills;\n    selectedRole;\n    preferedHobby;\n    isPersonAdult;\n\n    skills = [\n        {id: 1, name: 'Finance'}, \n        {id: 2, name: 'Human Resource'}, \n        {id: 3, name: 'Marketing'}\n    ];\n\n    roles = [\n        {id: 1, name: 'Manager'}, \n        {id: 2, name: 'VP'}, \n        {id: 3, name: 'Director'}, \n    ];\n\n    hobbiesList = [\n        {code: 1, name: 'Writing'},\n        {code: 2, name: 'Gym'},\n        {code: 3, name: 'Cooking'},\n    ];\n\n}\n</code></pre> <p>For comboboxes, binding is done on the <code>&lt;select&gt;</code> element using <code>(value)</code>, and when options come from a list, a placeholder can be used.</p> <p></p>"},{"location":"form/#form-validation-overview","title":"Form validation overview","text":"<p>Still.js provides with it's own validation capabilities which provides with a bunch of pre-defined ones. But also it allows custom validator to be added. Check Form Validation Directive.</p>"},{"location":"form/#in-summary","title":"In Summary","text":"<p>Forms are core part of Still.js, supporting 2-way binding using the <code>(value)</code> directive in most cases. However, for comboboxes and checkboxes, binding is done with the <code>(field)</code> directive.</p> <p>Fields bound to any form element are naturally available to be bound to the template, as well as can be listen to the changes reactively when changed.</p>"},{"location":"get-start/","title":"GET STARTED","text":""},{"location":"get-start/#basic-component-sample","title":"Basic component sample","text":"<p>All components extends from ViewComponent, and whenever gets rendered in the UI/browser can be assigned to the template variable as depicted below in lines 11 to 19.</p> HomeComponent.js <p>This component is placed under the app/home/ path<pre><code>import { ViewComponent } from \"../../@still/component/super/ViewComponent.js\";\n\nexport class HomeComponent extends ViewComponent {\n\n    /** \n     * isPublic flag is needed for any component that is publicly accessible, therefore, \n     * when dealing with authentication and permission scenario any component requiring\n     * user permission the flag will be removed or turned to false\n     */\n    isPublic = true;\n    template = `\n        &lt;div&gt;\n            &lt;h2&gt;Hello world!&lt;/h2&gt;\n            &lt;p&gt;\n            I'm an easy component with a button\n            &lt;/p&gt;\n            &lt;button&gt;I'm a button&lt;/button&gt;\n        &lt;/div&gt;\n    `;\n\n}\n</code></pre> Run result:</p> <p></p> <p></p>"},{"location":"get-start/#splitting-template-html-from-js-file","title":"Splitting Template (<code>.html</code>) from <code>.js</code> file","text":"<p>As long as both template/.html and .js files are in the same folder and have the are named similarly, we just need to remove the variable template from .js and it will be able to refer to the .html file instead. Tamplete splitting from .js file is quite usefull for complex template coding also making it more manageable and organized.</p> SlittedComponent.jsSlittedComponent.html This component is placed under the app/components/splitting/ path<pre><code>import { ViewComponent } from \"../../../@still/component/super/ViewComponent.js\";\n\nexport class SlittedComponent extends ViewComponent {\n    isPublic = true;\n}\n</code></pre> Teamplate file stays in the same folder as the component<pre><code>&lt;div&gt;\n    &lt;h3&gt;\n        This is the header for the splitted template file\n    &lt;/h3&gt;\n    &lt;br/&gt;\n    &lt;hr/&gt;\n    &lt;br/&gt;\n    &lt;p&gt;\n        Template splitted from the .js file is quite usefull especially on \n        those situations that the template content is quite extensive, \n        normally template inside the .js file can be natually used for smaller \n        template cases.\n    &lt;/p&gt;\n&lt;/div&gt;\n</code></pre> <p>Run result:</p> <p></p>"},{"location":"get-start/#event-handling","title":"Event handling","text":"<p>For event handling, we can create a method inside the component class, then we just need to bind it to any html element by assigning it to the (click) notation/directive as follow and highlighet in lines 12 and 16 to 18:</p> HomeWithEvent.js <p>This component is placed under the app/components/event/ path<pre><code>import { ViewComponent } from \"../../@still/component/super/ViewComponent.js\";\n\nexport class HomeWithEvent extends ViewComponent {\n\n    isPublic = true;\n    template = `\n        &lt;div&gt;\n            &lt;h2&gt;Hello world from HomeWithEvent!&lt;/h2&gt;\n            &lt;p&gt;\n            I'm an easy component with a button\n            &lt;/p&gt;\n            &lt;button (click)=\"callMe()\"&gt;I'm a button&lt;/button&gt;\n        &lt;/div&gt;\n    `;\n\n    callMe() {\n        alert(`Hi, you clicked me, I'm a button`);\n    }\n\n}\n</code></pre> Run result:</p> <p></p>"},{"location":"get-start/#state-binding-and-reactive-behavior","title":"State binding and reactive behavior","text":"<p>All dev defined variable are considered state which is managed by the components instance itself, when it comes to use it, any component calling it can use and listen to it. State binding can be achieved by using @stateVariableName inside the place where it's to be bound.</p> <p>Access to the state value is done by calling <code>.value</code> property, assigning a value is is done straight to the property itself.</p> CounterComponent.js <p>This component is placed under the app/components/counter/ path<pre><code>import { ViewComponent } from \"../../../@still/component/super/ViewComponent.js\";\n\nexport class CounterComponent extends ViewComponent {\n\n    isPublic = true;\n    /**\n     * This is a state since no annotation or signature is put for it\n     */\n    count = 0;\n\n    template = `\n    &lt;div&gt;\n        &lt;p&gt;\n            My counter state is @count\n        &lt;/p&gt;\n        &lt;button (click)=\"increment()\"&gt;Increment (@count)&lt;/button&gt;\n        &lt;button (click)=\"decrement()\"&gt;Decrement (@count)&lt;/button&gt;\n    &lt;/div&gt;\n    `;\n\n    increment() {\n        this.count = this.count.value + 1;\n    }\n\n    decrement() {\n        this.count = this.count.value - 1;\n    }\n\n}\n</code></pre> Run result:</p> <p></p>"},{"location":"get-start/#two-way-data-binding-and-forms","title":"Two-way data binding and Forms","text":"<p>When building a form, in several situations Two-way data binding is needed, the (value) notation/directive is provided in which we only need to assign the state in which we are binding out form input, also input needs to be wrapped by a form (&lt;form&gt;&lt;/form&gt;).</p> BasicForm.js <p>This component is placed under the app/components/form/ path<pre><code>import { ViewComponent } from \"../../../@still/component/super/ViewComponent.js\";\n\nexport class BasicForm extends ViewComponent {\n\n    isPublic = true;\n    firstName = '';\n    shoeSize;\n\n    template = `\n    &lt;div&gt;\n        &lt;form&gt;\n            &lt;div class=\"form-group\"&gt;\n                &lt;label&gt;First Name&lt;/label&gt;\n                &lt;input (value)=\"firstName\" type=\"text\"  placeholder=\"Enter first name\"&gt;\n            &lt;/div&gt;\n            &lt;br/&gt;\n            &lt;div class=\"form-group\"&gt;\n                &lt;label&gt;Shoe Size&lt;/label&gt;\n                &lt;input \n                    (value)=\"shoeSize\" \n                    (validator)=\"number\" \n                    (validator-warn)=\"Invalid shoe size, number is required\"\n                    placeholder=\"Enter valid shoe size\"\n                &gt;\n            &lt;/div&gt;\n        &lt;/form&gt;\n        &lt;br/&gt;\n        &lt;p&gt;Welcome &lt;b&gt;@firstName&lt;/b&gt;&lt;/p&gt;\n        &lt;br/&gt;\n        &lt;button (click)=\"setFirstName('Michael')\"&gt;Set Michael&lt;/button&gt;\n        &lt;button (click)=\"setFirstName('Dario')\"&gt;Set Dario&lt;/button&gt;\n    &lt;/div&gt;\n    `;\n\n    /** Single line method using arrow function */\n    setFirstName = (val) =&gt; this.firstName = val;\n\n}\n</code></pre> Run result:</p> <p>Input/Form grouping Important consideration</p> <p>Still.js adopts the Bootstrap approach when it comes to form group, though it's not needed, this is quite helpfull to organizing form component by adding it (Bootstrap) as part of the project, also it helps properly handle alignment/positioning like labels and validation messages.</p> <p></p> <p></p>"},{"location":"get-start/#conditional-rendering-and-conditional-hideunhide","title":"Conditional rendering and Conditional Hide/Unhide","text":"<p>By creating a variable annotated with @Prop (using JSDoc approach) we can then use this as flags (or any other application flow value) thereby being possible to assigne it on the Still.js directive, in this case to render or not, or hide/unhide (renderIf) and (showIf) notations are provided respectively.</p> BasicConditionalView.js <p>This component is placed under the app/components/conditoinal-render/ path<pre><code>import { ViewComponent } from \"../../../@still/component/super/ViewComponent.js\";\n\nexport class BasicConditionalView extends ViewComponent {\n\n    isPublic = true;\n\n    /**\n     * The props differ from state (which does not have any annotation)\n     * in a way that state allow to trace changes which is also useful\n     * in the component to component communication scenario in real time/reactively\n     * @Prop \n     */\n    isAdminPermisison = false;\n\n    //Annotation can be put in the same line of the prop/variable\n    /** @Prop */ shouldShowContent = true;\n\n    addLabel = 'Hide';\n    adminLabel = 'Unable';\n\n    template = `\n        &lt;div&gt;\n            &lt;div (renderIf)=\"self.isAdminPermisison\"&gt;\n                Hello, this part of the content wont be rendered since\n                the flag on (renderIf) is false, even if you click\n                in the second button which turns flag to true\n            &lt;/div&gt;\n\n            &lt;p (showIf)=\"self.shouldShowContent\"&gt;\n            If you click the button bellow this content will be unhide\n            &lt;br&gt;in case flag is true, and hidden if false\n            &lt;/p&gt;\n            &lt;button (click)=\"hideOrUnhide()\"&gt;@addLabel content&lt;/button&gt;\n            &lt;button (click)=\"renderContent()\"&gt;@adminLabel Admin&lt;/button&gt;\n        &lt;/div&gt;\n    `;\n\n    hideOrUnhide() {\n        this.addLabel = 'Hide';\n        this.shouldShowContent = !this.shouldShowContent;\n        if (!this.shouldShowContent) this.addLabel = 'Unhide';\n    }\n\n    renderContent() {\n        this.adminLabel = 'Unable';\n        this.isAdminPermisison = !this.isAdminPermisison;\n        if (this.isAdminPermisison) this.adminLabel = 'Able';\n    }\n\n}\n</code></pre> Run result:</p> <p></p>"},{"location":"get-start/#adding-css-styles","title":"Adding CSS Styles","text":"<p>Everything is base in Vanilla web technologies, therefore we can just write CSS naturally by creating the  scope, but it it also allows inline CSS if needed just like normall HTML with css in it.</p> FormatedDataTable.js <p>This component is placed under the app/components/styled/ path<pre><code>import { ViewComponent } from \"../../../@still/component/super/ViewComponent.js\";\n\nexport class FormatedDataTable extends ViewComponent {\n\n    isPublic = true;\n    template = `\n\n        &lt;style&gt;\n            ol {\n                display: table;\n                width: 98%;\n                border: 1px solid black;\n            }\n            li, ol::before { display: table-row }\n\n            ol::before { content: \"\" }\n\n            li span {\n                display: table-cell;\n                border: 1px solid black;\n                padding: 8px;\n            }\n\n            li:nth-child(odd) { background: lightgrey; }\n\n            li:first-child {\n                font-weight: bold;\n                background-color: grey;\n            }\n\n        &lt;/style&gt;\n        &lt;h2&gt;Ordered List Styled as a Table&lt;/h2&gt;\n\n        &lt;ol&gt;\n            &lt;li&gt;\n                &lt;span&gt;#&lt;/span&gt;\n                &lt;span&gt;Item&lt;/span&gt;\n            &lt;/li&gt;\n            &lt;li&gt;\n                &lt;span&gt;1&lt;/span&gt;\n                &lt;span&gt;Apple&lt;/span&gt;\n            &lt;/li&gt;\n            &lt;li&gt;\n                &lt;span&gt;2&lt;/span&gt;\n                &lt;span&gt;Banana&lt;/span&gt;\n            &lt;/li&gt;\n            &lt;li&gt;\n                &lt;span&gt;3&lt;/span&gt;\n                &lt;span&gt;Grapes&lt;/span&gt;\n            &lt;/li&gt;\n            &lt;li&gt;\n                &lt;span&gt;4&lt;/span&gt;\n                &lt;span&gt;Orange&lt;/span&gt;\n            &lt;/li&gt;\n            &lt;li&gt;\n                &lt;span&gt;5&lt;/span&gt;\n                &lt;span&gt;Mango&lt;/span&gt;\n            &lt;/li&gt;\n        &lt;/ol&gt;\n    `;\n\n}\n</code></pre> Run result:</p> <p></p>"},{"location":"get-start/#basics-of-component-embeding","title":"Basics of Component Embeding","text":"<p>Bringing a component inside another in general is achievable by using the <code>&lt;st-element&gt;&lt;/st-element&gt;</code> tag where we can then specify the component name we want to embed as child (tag property as line 16), additional child component property (e.g. lines 18 and 19) and event handlers also can be passed the same way (in the tag) as long as they child difined it.</p> Parent ComponentChild Component UserForm.js - This component is placed under the app/components/embed/ path<pre><code>import { ViewComponent } from \"../../../@still/component/super/ViewComponent.js\";\n\nexport class UserForm extends ViewComponent {\n\n    isPublic = true;\n\n    /** @Prop */\n    childTitleState = 'Child Title from Parent';\n    changeCounter = 0;\n\n    template = `\n        &lt;button (click)=\"updateChildTitle()\"&gt;Change child title&lt;/button&gt;\n        &lt;br/&gt;\n        &lt;br/&gt;\n        &lt;st-element \n            component=\"UserGrid\"\n            ref=\"insideFormGridReference\"\n            tableTitle=\"self.childTitleState\"\n            titleMergeSize=\"5\"\n            &gt;\n        &lt;/st-element&gt;\n    `;\n\n    updateChildTitle() {\n\n        this.changeCounter = this.changeCounter.value + 1;\n\n        /** @type { UserGrid } */\n        const userGridObj = Components.ref('insideFormGridReference');\n        userGridObj.tableTitle = 'Title altered ' + this.changeCounter.value + 'x';\n    }\n\n}\n</code></pre> UserGrid.js - This component is placed under the app/components/embed/ path<pre><code>import { ViewComponent } from \"../../../@still/component/super/ViewComponent.js\";\n\nexport class UserGrid extends ViewComponent {\n\n    isPublic = true;\n\n    tableTitle = \"Users List Not changed\";\n    /** @Prop */\n    titleMergeSize;\n\n    template = `\n        &lt;table border=\"1\"&gt;\n            &lt;thead&gt;\n                &lt;tr&gt;&lt;th colspan=\"@titleMergeSize\"&gt;@tableTitle&lt;/td&gt;&lt;/tr&gt;\n                &lt;tr&gt;\n                    &lt;th&gt;ID&lt;/th&gt;\n                    &lt;th&gt;Name&lt;/th&gt;\n                    &lt;th&gt;Email&lt;/th&gt;\n                    &lt;th&gt;Age&lt;/th&gt;\n                    &lt;th&gt;Country&lt;/th&gt;\n                &lt;/tr&gt;\n            &lt;/thead&gt;\n            &lt;tbody&gt;\n                &lt;tr&gt;\n                    &lt;td&gt;1&lt;/td&gt;\n                    &lt;td&gt;John Doe&lt;/td&gt;\n                    &lt;td&gt;john@example.com&lt;/td&gt;\n                    &lt;td&gt;28&lt;/td&gt;\n                    &lt;td&gt;USA&lt;/td&gt;\n                &lt;/tr&gt;\n                &lt;tr&gt;\n                    &lt;td&gt;2&lt;/td&gt;\n                    &lt;td&gt;Jane Smith&lt;/td&gt;\n                    &lt;td&gt;jane@example.com&lt;/td&gt;\n                    &lt;td&gt;32&lt;/td&gt;\n                    &lt;td&gt;UK&lt;/td&gt;\n                &lt;/tr&gt;\n            &lt;/tbody&gt;\n        &lt;/table&gt;\n\n    `;\n}\n</code></pre> <p>Run result:</p> <p></p>"},{"location":"get-start/#basics-of-navigation","title":"Basics of Navigation","text":"<p>Whe using still-cli (<code>@stilljs/cli</code> - which is the recommended way) to generate the component, both route name (same as component name) and component URL will be added automatically in the <code>route.map.js</code> file in the project root folder, therefore, navigation can be done the way it workes in regular web pages. in the bellow code navigation is done by using route name. </p> First ComponentSecond ComponentRouting file EntryMenu.js - This component is placed under the app/components/menu/ path<pre><code>import { ViewComponent } from \"../../../@still/component/super/ViewComponent.js\";\n\nexport class EntryMenu extends ViewComponent {\n\n    isPublic = true;\n    template = `\n        &lt;div&gt;\n            This is Entry menu component, press the bellow \n            &lt;br/&gt;button or in the link to navigate to User\n            &lt;br/&gt;\n            &lt;br/&gt;\n            &lt;button (click)=\"goto('UserRegistration')\"&gt;Register user&lt;/button&gt;\n        &lt;/div&gt;\n    `;\n\n}\n</code></pre> UserRegistration.js - This component is placed under the app/components/user/ path<pre><code>import { ViewComponent } from \"../../../@still/component/super/ViewComponent.js\";\n\nexport class UserRegistration extends ViewComponent {\n\n    isPublic = true;\n    template = `\n        &lt;div class=\"user-reg-container\"&gt;\n            &lt;span class=\"smile-icone\"&gt;&amp;#9787;&lt;/span&gt; \n            &lt;br/&gt;\n            This is the user registration component\n            &lt;br/&gt;\n            &lt;button (click)=\"goto('EntryMenu')\"&gt;Go to Menu&lt;/button&gt;\n        &lt;/div&gt;\n\n        &lt;style&gt;\n            .user-reg-container { text-align: center; }\n            .smile-icone { \n                color: orange;\n                font-size: 60px;\n            }\n        &lt;/style&gt;\n    `;\n\n}\n</code></pre> route.map.js - This is a framework core file whichs stays in the project root dir<pre><code>export const stillRoutesMap = {\n    viewRoutes: {\n        regular: {\n            EntryMenu: { path: \"app/components/routing\" },\n            UserRegistration: { path: \"app/components/routing\" }\n        },\n        lazyInitial: {}\n    }\n}\n</code></pre> <p>Run result:</p> <p></p>"},{"location":"get-start/#dom-manipulation","title":"DOM Manipulation","text":"<p>Because Still.js is 100% pure/Vanilla JavaScript, DOM manipulation can be done straight as the native/regular DOM API, no workaround or additional layer/special coding is needed. </p> EntryMenu.js This component is placed under the app/components/dom/ path<pre><code>import { ViewComponent } from \"../../../@still/component/super/ViewComponent.js\";\n\nexport class LoginComponent extends ViewComponent {\n\n    isPublic = true;\n\n    userName;\n    password;\n\n    template = `\n        &lt;form onsubmit=\"return false;\"&gt;\n            &lt;div&gt;Type the same for both user and password for &lt;br&gt;success login, something else for invalid&lt;div&gt;\n\n            Username: &lt;input type=\"text\" (value)=\"userName\"&gt;\n            &lt;br&gt;&lt;br&gt;\n            Password: &lt;input type=\"password\" (value)=\"password\"&gt;&lt;br&gt;\n\n            &lt;span id=\"loginStatus\"&gt;&lt;/span&gt;&lt;br&gt;\n\n            &lt;button (click)=\"processLogin()\"&gt;Login&lt;/button&gt;\n        &lt;/form&gt;\n    `;\n\n    processLogin() {\n\n        const user = this.userName.value;\n        const password = this.password.value;\n        const messageContainer = document.getElementById('loginStatus');\n\n        if (user !== password || user == '' || password == '') {\n            /** Assignin new content via DOM manipulation */\n            messageContainer.innerHTML = 'Invalid user or password';\n            /** CSS updating through DOM */\n            messageContainer.style = 'color: red; background-color: #ab1f1f38;';\n            /** Changing inputs border via DOM manipulation */\n            document.querySelector('input[type=text]').style = 'border: 1px solid red';\n            document.querySelector('input[type=password]').style = 'border: 1px solid red';\n\n        } else {\n            /** Assignin new content via DOM manipulation */\n            messageContainer.innerHTML = 'User login success! &amp;#9787;';\n            /** CSS updating through DOM */\n            messageContainer.style = 'color: green; background-color: none;';\n            /** Changing inputs border via DOM manipulation */\n            document.querySelector('input[type=text]').style = 'border: 1px solid green';\n            document.querySelector('input[type=password]').style = 'border: 1px solid green';\n        }\n    }\n\n}\n</code></pre> <p>Run result:</p> <p></p>"},{"location":"get-start/#looping-and-rendering-from-a-list","title":"Looping and Rendering from a List","text":"<p>Lopping a list and rendering its items is quite simple, Still.js provides the (forEach) notation/directive, which can be pass to a top level container which is then used to wrap the template for the desired output of each list item. </p> LoopingDirective.jsShoppingItem.js This component is placed under the app/components/looping/ path<pre><code>import { ViewComponent } from \"../../../@still/component/super/ViewComponent.js\";\n\nexport class LoopingDirective extends ViewComponent {\n\n    isPublic = true;\n\n    /** This is the list of products ( data source ) */\n    productList = [\n        { name: 'Orange', sold: 3, stockAvail: 7, price: '0.75$' },\n        { name: 'Apple', sold: 1, stockAvail: 5, price: '0.88$' },\n        { name: 'Banana', sold: 10, stockAvail: 50, price: '1.03$' },\n    ]\n\n    template = `\n        &lt;div&gt;\n            &lt;h5&gt;Looping with HTML child&lt;/h5&gt;\n            &lt;br&gt;\n            &lt;span (forEach)=\"productList\"&gt;\n                Stock Availability\n                &lt;div each=\"item\"&gt;\n                    &lt;b&gt;Name:&lt;/b&gt; {item.name} - &lt;b&gt;Sock:&lt;/b&gt; {item.stockAvail} - &lt;b&gt;Price:&lt;/b&gt; {item.price}\n                &lt;/div&gt;\n            &lt;span&gt;\n        &lt;/div&gt;\n\n        &lt;br&gt;&lt;hr&gt;&lt;br/&gt;\n\n        &lt;div&gt;\n            &lt;h5&gt;Looping with child Component&lt;/h5&gt;\n            &lt;br&gt;\n            &lt;span (forEach)=\"productList\"&gt;\n                Shipping Cart Checkout\n                &lt;!-- Fields are mapped one to one from data \n                    source (productList) to the child component state --&gt;\n                &lt;st-element component=\"ShoppingItem\" each=\"item\"&gt;&lt;/st-element&gt;\n            &lt;span&gt;\n        &lt;/div&gt;\n    `;\n}\n</code></pre> This component is placed under the app/components/looping/ path<pre><code>import { ViewComponent } from \"../../../@still/component/super/ViewComponent.js\";\n\nexport class ShoppingItem extends ViewComponent {\n\n    isPublic = true;\n\n    /**\n     * Bellow states (name, sold, price) are being mapped directly since those\n     * names coincides with each item in the Data source in the parent component\n     */\n    name;\n    sold;\n    price;\n\n    template = `\n        &lt;div class=\"shoping-item-card\"&gt;\n            &lt;span&gt;Produce Name: @name&lt;/span&gt;\n            &lt;span&gt;Quantity: @sold&lt;/span&gt;\n            &lt;span&gt;Price: @price&lt;/span&gt;\n        &lt;/div&gt;\n\n        &lt;style&gt;\n            .shoping-item-card{ display: flex; }\n\n            .shoping-item-card span:first-child { width: 30%; }\n\n            .shoping-item-card span:last-child { border-right: none; }\n\n            .shoping-item-card span {\n                border-right: 1px solid black;\n                padding: 2px 5px; width: 18%;\n                text-align: center; display: block;\n            }\n        &lt;/style&gt;\n    `;\n}\n</code></pre> <p>Run result:</p> <p> </p>"},{"location":"installation-and-running-cdn/","title":"Setup OPTION 2 - Using CDN","text":""},{"location":"installation-and-running-cdn/#using-cdn-for-lone-component-andor-microfrontend","title":"Using CDN For Lone Component and/or Microfrontend","text":"<p>In the CND mode, instead of the whole folder structure, only the <code>app</code> folder and <code>route.map.js</code> file are needed, also, we need to set the path where they'll be placeed by using the <code>STILL_HOME</code> variable, follow the folder structure example as well as coding sample right after:</p> <p></p> <p></p>"},{"location":"installation-and-running-cdn/#1-folder-structure","title":"1. Folder Structure","text":"<p>First thing first, Still.js CDN based project are also named Lone component, and it's recommender for them to be create using <code>still-cli</code> in addition to add to CDN in the page file itself (e.g. .html), as both the <code>app/</code> folder and the <code>route.map.js</code> file are needed even in this case, but the framework will be served from the CDN itself, hence, project structure can be as follow: </p> Folder structure in CDN mode <pre><code>my-project-name\n|\n|_ microfronteds\n|  |_ still\n|  |  |_ app\n|  |  |  |_ components\n|  |  |_ config\n|  |  |  |_ route.map.js\n|  |_ another-mf-provider\n|_ index.html\n</code></pre>"},{"location":"installation-and-running-cdn/#a-creating-lonecdn-based-project","title":"a. Creating Lone/CDN based project:","text":"<p>Creating the project inside the <code>microfrontend/sill/</code> folder: <pre><code>npx still lone\n</code></pre></p> <p>Project folder substructure considerations</p> <p>In the above example structure, we have a folder name <code>microfronted</code>, where we have the <code>still</code> sub-folder, and, we also have <code>component</code> folder inside the app root, nevertheless all 3 (microfronted, still and component) can be named as per the dev will.</p> <p> </p>"},{"location":"installation-and-running-cdn/#2-basic-code-sample","title":"2. Basic code sample","text":"index.htmlCounterComponent.jsroute.map.js <pre><code>&lt;!DOCTYPE html&gt;\n&lt;html lang=\"en\"&gt;\n    &lt;head&gt;\n        &lt;script&gt; STILL_HOME = 'microfronteds/still/' &lt;/script&gt;\n        &lt;link href=\"https://cdn.jsdelivr.net/npm/@stilljs/core@latest/@still/ui/css/still.css\" rel=\"stylesheet\"&gt;\n        &lt;script src=\"https://cdn.jsdelivr.net/npm/@stilljs/core@latest/@still/lone.js\"type=\"module\"&gt;&lt;/script&gt;\n    &lt;/head&gt;\n    &lt;body&gt;\n        &lt;st-element component=\"CounterComponent\"&gt;&lt;/st-element&gt;\n    &lt;/body&gt;\n&lt;/html&gt;\n</code></pre> <pre><code>/** \n * This file will be place inside the components folder\n * according to the above folder structure \n * */\nexport class CounterComponent extends ViewComponent {\n\n    isPublic = true;\n    count = 0;\n\n    template = `\n    &lt;div&gt;\n        &lt;p&gt;My counter state is @count&lt;/p&gt;\n        &lt;button (click)=\"increment()\"&gt;Increment (@count)&lt;/button&gt;\n    &lt;/div&gt;\n    `;\n\n    increment() {\n        this.count = this.count.value + 1;\n    }\n}\n</code></pre> <pre><code>/** \n * This file will be placed inside config/ folder which is in the \n * same level as app/ folder, and both are inside the still folder\n * */\nexport const stillRoutesMap = {\n    viewRoutes: {\n        regular: {\n            CounterComponent: { path: \"app/components/\" }\n        },\n        lazyInitial: {}\n    }\n}\n</code></pre> <p>We can add our components in our HTML/App (React, Angular, etc.) by using<code>&lt;st-element&gt;</code> tag instead of depending on the Still.js Application container to render the components, as it (Application container) is totally inexistent in this case.</p> <p>Component creation</p> <p>Although we don't have Still project structure in CDN mode, it's always recommended to use the still-cli to generate components, as this is the way the routes will be automatically added/managed in addition to the component generation.</p> <p>Routing and route.map.js file</p> <p>Despite Still App container is not available in the CND mode, navigation feature is still available, plus, it's needed for the framework to know how to locate the components, hence the route.map.js file.</p> <p></p>"},{"location":"installation-and-running-cdn/#3-running-the-project-in-cdn-mode","title":"3. Running the project in CDN mode","text":"<p>The proper way of running the project in the CDN mode is by having it from a web server, we'll use <code>live-server</code> in this example, for that let's first install it:</p> <pre><code>npm i -g live-server\n</code></pre> <p>Running the project from inside the project root folder ( <code>my-project-name</code> ) <pre><code>npx live-server\n</code></pre></p> <p>Run result:</p> <p></p>"},{"location":"installation-and-running-cdn/#cdn-files","title":"CDN Files","text":"JavaScript:  <pre><code>https://cdn.jsdelivr.net/npm/@stilljs/core@latest/@still/lone.js\n</code></pre>  CSS:  <pre><code>https://cdn.jsdelivr.net/npm/@stilljs/core@latest/@still/ui/css/still.css\n</code></pre> You're good to go! enjoy your coding."},{"location":"installation-and-running/","title":"Setup OPTION 1 - Still.js Project","text":""},{"location":"installation-and-running/#creating-a-stilljs-project","title":"Creating a Still.js Project","text":""},{"location":"installation-and-running/#1-installation","title":"1. Installation","text":"<pre><code>npm install @stilljs/cli -g\n</code></pre> <p>In pricinple, still.js application development process is tied to the NPM, therefore, for it to be available in our machine we need to make a global (-g) installation.</p> <p>Once installed, still-cli can be invoked from the terminal by typing <code>npx still</code> to see the available commands and ooptions.</p> <p></p>"},{"location":"installation-and-running/#2-creating-a-project","title":"2. Creating a project","text":"<p>Create a folder for you project (e.g. project-name) and from inside such folder init the project as the bellow instruction <pre><code>npx still init\n</code></pre></p> <p>After initiating the project the framework structure and files are download to the folder.</p> <p></p>"},{"location":"installation-and-running/#3-acessing-the-project-project-structure","title":"3. Acessing the project (Project structure)","text":"<pre><code>    project-name/ //My project folder\n    |__ @still/ // Still.js framework\n    |__ app/ // Folder which holdes to app files\n    |     |__ HomeComponent.js //Component generated automatically when creating project\n    |__ config/ //Folder which holds application configuration files\n    |     |__ app-setup.js //App configuration file/class\n    |     |__ app-template.js //App template scheleton\n    |     |__ route.map.json //Component routing and path file\n    |__ index.html //Application container\n    |__ jsconfig.js //Basic configuration for vscode\n    |__ package.json // Regular package JSON\n</code></pre> <p>In the above picture we have the project structure open in the code editor, everything concerning the project will be created inside the app folder. Inicially the app folder comes with one component which path is app/home/HomeComponent.js as also depicted in the picture.</p> <p></p>"},{"location":"installation-and-running/#4-running-the-project","title":"4. Running the project","text":"<p><code>npx still app serve</code></p> <p>The above command needs to bu run in the terminal from the project folder as dipicted bellow:</p> <p></p> <p> After typing for serving the project it gets oppened automatically in the browser as in the bellow picture:</p> <p></p> You're all set! enjoy your coding. <p></p>"},{"location":"integration-with-react/","title":"Integration with React (Microfrontend)","text":""},{"location":"integration-with-react/#using-stilljs-for-microfrontend-development-into-react","title":"Using Still.js for Microfrontend development into React","text":"<p>Work in Progress - Completed Soon</p> <p>We're still bringing and elaborating additional content which will be part of this page, please just be a bit patient, completed soon.</p>"},{"location":"integration-with-react/#overview","title":"Overview","text":"<p>Due to it's nature, Still.js provides advanced capabilities which allow it to integrate or being embedded inside applications developed with other Frameworks. This documentation is dedicated dedicated to integration with React.</p> <p>Check this for microservices using Vanilla setup (e.g. PHP, JSP, ASP, Regular template engines, etc).</p> <p></p>"},{"location":"integration-with-react/#1-integration-conditions","title":"1. Integration conditions","text":"<p>In order for Still.js to integrate with React, we have to add the Still app inside the React app in a folder that is not parsed by React itself. The considerations of this documentation focus on a project generated with Vite, anyway things will work the same for any other approach as long as project structure is followd accordingly.</p> <p>Bellow is the example of a structure of a React project with Still.js inside the <code>public/</code> folder:</p> <p></p> <p></p>"},{"location":"integration-with-react/#2-stilljs-available-features-under-react-as-microfrontend","title":"2. Still.js available features under React as Microfrontend","text":"<p>Still.js is a full-featured framework, just as React it provides natively all those known capabilities (e.g. Navigation, Validation) and more. No matter how you're running your Still app, whether it's as microservice of as independent, same capabilities are provided. </p> <p>One of the interesting features that are 100% available is the navigation, you can yet navigate from one componet into another in your Microfrontend without impacting the regular React navigation, due to that, Still allow not only a component to be embedded, but a whole application.</p> <p></p>"},{"location":"integration-with-react/#3-installation-and-setup","title":"3. Installation and Setup","text":"<p>For more details about setting up, follow the README on npm, under the @stilljs/apploader.</p> Enjoy your coding. <p></p>"},{"location":"lifecycle-hooks/","title":"LIFECYCLE HOOKS","text":""},{"location":"lifecycle-hooks/#overview","title":"Overview","text":"<p>Still provides with different types of Hooks not only when it comes to component Lifecycle but for additional specific context. Services (<code>@Inject</code> annotation) and Proxies (<code>@Proxy</code> annotation) also provide a hook (see this example) that can be used for components to subscribe so that they get triggered/notified when the service is loaded/ready.</p> <p></p>"},{"location":"lifecycle-hooks/#component-lifecycle-hooksspecial-methods","title":"Component Lifecycle Hooks/Special Methods","text":"<p>Essentially, in Still.js the component Lifecycle comprises 4 special methods (Hooks) as depicted in blue rectangles in the bellow diagram: </p> <p>.</p> <p> </p> <p></p>"},{"location":"lifecycle-hooks/#examples-setup","title":"Examples Setup","text":"<p>The examples in this documentation/tutorials will be base in the bellow folder structure, Application Setup (<code>app-setup.js</code>) and routes metadata (<code>route.map.js</code>)</p>  Project folder structureapp-setup.jsroute.map.js Project folder structure<pre><code>project-root-folder\n|__ @still/\n|__ app/\n|    |\n|    |__ base-components/\n|    |   |__ HomeComponent.js\n|    |   |\n|    |__ person/\n|    |   |__ PersonForm.js\n|    |   |\n|    |__ services/\n|    |   |__ MainService.js\n|    |   |   |\n|__ config/\n|    |__ app-setup.js\n|    |__ route.map.js\n|__  ...\n</code></pre> This is the where Application context aspects are setup. This file is in the root folder.<pre><code>import { StillAppMixin } from \"./@still/component/super/AppMixin.js\";\nimport { Components } from \"./@still/setup/components.js\";\nimport { AppTemplate } from \"./app-template.js\";\nimport { HomeComponent } from \"./app/base-components/HomeComponent.js\";\n\nexport class StillAppSetup extends StillAppMixin(Components) {\n\n    constructor() {\n        super();\n        //Defines the first component to load\n        this.setHomeComponent(HomeComponent);\n    }\n\n    async init() {\n        //Loads the app container and the initial component set at line 11\n        return await AppTemplate.newApp();\n    }\n\n}\n</code></pre> This is the where Application context aspects are setup. This file is in the root folder.<pre><code>export const stillRoutesMap = {\n    viewRoutes: {\n        regular: {\n            HomeComponent: {\n                path: \"app/base-components\",\n                url: \"/home\"\n            },\n            PersonForm: {\n                path: \"app/person\",\n                url: \"/person/register\" //This url was changed conviniently\n            }\n        },\n        lazyInitial: {}\n    }\n}\n</code></pre> <p> </p>"},{"location":"lifecycle-hooks/#the-stonrender-special-method-hook","title":"The <code>stOnRender()</code> Special method (Hook)","text":"<p>This example takes into consideration the above folder structure, app and routing setup.</p> <p>This hook runs immediately after the component is instantiated. While the component isn't fully ready yet, it's suitable for actions like making API calls or showing a loading spinner.</p> HomeComponent.js This component is placed in the app/base-components/ folder<pre><code>import { ViewComponent } from \"../../@still/component/super/ViewComponent.js\";\n\nexport class HomeComponent extends ViewComponent {\n\n    isPublic = true;\n\n    template = `Hooks example`;\n\n    stOnRender() {\n        console.log(`Component was created but not ready for use yet`);\n    }\n\n}\n</code></pre> <p> </p>"},{"location":"lifecycle-hooks/#the-stafterinit-special-method-hook","title":"The <code>stAfterInit()</code> Special method (Hook)","text":"<p>This example takes into consideration the above folder structure, app and routing setup.</p> <p>This takes place whenever the component was render and it's totally available for usage, in this stage we can for example access to DOM tree of such component.</p> HomeComponent.js <p>This component is placed in the app/base-components/ folder<pre><code>import { ViewComponent } from \"../../@still/component/super/ViewComponent.js\";\n\nexport class HomeComponent extends ViewComponent {\n\n    isPublic = true;\n\n    template = `\n        &lt;div \n            id=\"theId\"&gt;\n            Hooks example\n        &lt;/div&gt;`;\n\n    stAfterInit() {\n        console.log(`Component was rendered, and ready to be manipulated, printing its HTML content bellow:`);\n        console.log(document.getElementById('theId').innerHTML);\n    }\n\n\n}\n</code></pre> </p>"},{"location":"lifecycle-hooks/#the-stonupdate-special-method-hook","title":"The <code>stOnUpdate()</code> Special method (Hook)","text":"<p>This example takes into consideration the above folder structure, app and routing setup.</p> <p>This hook takes place everytime a component state gets changed since this is the change that reflects the UI. Component update triggers either the component updates itself or by another component.</p> HomeComponent.jsPersonForm.js This component is placed in the app/base-components/ folder<pre><code>import { ViewComponent } from \"../../@still/component/super/ViewComponent.js\";\nimport { PersonForm } from \"../person/PersonForm.js\";\n\nexport class HomeComponent extends ViewComponent {\n\n    isPublic = true;\n\n    /** @Proxy @type { PersonForm } */\n    personForm;\n\n    template = `\n        &lt;div&gt;\n            Home component which embeds another and set a proxy\n            &lt;button (click)=\"changePersonText()\"&gt;Change Person&lt;/button&gt;\n        &lt;/div&gt;\n        &lt;st-element \n            component=\"PersonForm\"\n            proxy=\"personForm\"\n        &gt;&lt;/st-element&gt;\n    `;\n\n    changePersonText() {\n        //This will update a state variable of the embeded component (PersonForm)\n        this.personForm.myText = 'New Value';\n    }\n}\n</code></pre> This component is placed in the app/person/ folder<pre><code>import { ViewComponent } from \"../../@still/component/super/ViewComponent.js\";\n\nexport class PersonForm extends ViewComponent {\n\n    isPublic = true;\n\n    //This is a state which reactively \n    //updates in case its value gets changed\n    myText = 'Initial value';\n\n    template = `\n        &lt;div&gt;\n            &lt;p&gt;My state is bound and will be updated by parent&lt;/p&gt;\n            &lt;p&gt;@myText&lt;/p&gt;\n        &lt;/div&gt;\n    `;\n\n    //Hooks that takes place when state update happens\n    stOnUpdate() {\n        console.log(`I'm being updated by another component`);\n    }\n\n}\n</code></pre> <p></p> <p></p>"},{"location":"lifecycle-hooks/#the-stonunload-special-method-hook","title":"The <code>stOnUnload()</code> Special method (Hook)","text":"<p>This example takes into consideration the above folder structure, app and routing setup.</p> <p>It takes place especially when destroying a component, which happens when navigating from one component or page to another. A basic use case for it would be if we need to clear some data in a global store (Service).</p> HomeComponent.jsPersonForm.jsMainService.js This component is placed in the app/base-components/ folder<pre><code>import { ViewComponent } from \"../../@still/component/super/ViewComponent.js\";\nimport { MainService } from \"../services/MainService.js\";\n\nexport class HomeComponent extends ViewComponent {\n\n    isPublic = true;\n\n    /** \n     * @Inject\n     * @Path services/\n     * @type { MainService } \n     * */\n    serviceObj;\n\n    template = `\n        &lt;div&gt;\n            &lt;p&gt;This is the home, click bellow to go to Person Form&lt;/p&gt;\n            &lt;button (click)=\"goto('PersonForm')\"&gt;Register Person&lt;/button&gt;\n        &lt;/div&gt;\n    `;\n\n    stOnRender() {\n        // Bellow variable will hold a very bi API response data\n        const apiResponse = [];\n        //In here we substribe to the service onLoad hook\n        this.serviceObj.on('load', () =&gt; {\n            // Assigning the API response to the Store\n            this.serviceObj.personStore = apiResponse;\n        });\n    }\n\n    stOnUnload() {\n        console.log(`BEFORE CLEARING: `, this.serviceObj.personStore.value);\n        this.serviceObj.personStore = null;\n        console.log(`AFTER CLEARING: `, this.serviceObj.personStore.value);\n    }\n\n}\n</code></pre> This component is placed in the app/person/ folder<pre><code>import { ViewComponent } from \"../../@still/component/super/ViewComponent.js\";\n\nexport class PersonForm extends ViewComponent {\n\n    isPublic = true;\n\n    template = `\n        &lt;div&gt;\n            &lt;p&gt;This is the PersonForm content&lt;/p&gt;\n        &lt;/div&gt;\n    `;\n\n}\n</code></pre> This service is placed in the app/services/ folder<pre><code>import { BaseService, ServiceEvent } from \"../../@still/component/super/service/BaseService.js\";\n\nexport class MainService extends BaseService {\n\n    personStore = new ServiceEvent([]);\n\n}\n</code></pre> <p> </p>"},{"location":"lifecycle-hooks/#the-stwhenready-special-method-hook","title":"The <code>stWhenReady()</code> Special method (Hook)","text":"<p>This example takes into consideration the above folder structure, app and routing setup.</p> <p>This is a hook that works the same way as the <code>stAfterInit()</code>, the only different is that it's not called in the class level but inside a method in the class (e.g. <code>constructor</code>). A use case for this hook would be when the implementing component needs to run something on top of another unrelated (nor sibling or child) component gets loaded/rendered since it would never have controle over it.</p> HomeComponent.js This component is placed in the app/base-components/ folder<pre><code>import { ViewComponent } from \"../../@still/component/super/ViewComponent.js\";\n\nexport class HomeComponent extends ViewComponent {\n\n    isPublic = true;\n\n    myStateVariable = 'My Initial value';\n\n    template = `Hooks example using stWhenReady()`;\n\n    constructor() {\n        super();\n\n        this.stWhenReady(() =&gt; {\n            console.log(`My State value is: `, this.myStateVariable.value)\n        });\n    }\n\n}\n</code></pre> <p> </p>"},{"location":"lone-component/","title":"Lone component and Microfrontend","text":""},{"location":"lone-component/#overview","title":"Overview","text":"<p>The Lone Component, also known as CDN-based project, allows embedding Still.js components into other web applications without relying on the Still Application container. When done via CDN it must follow a minimal project structure having the <code>app/</code> folder for components and the <code>route.map.js</code> file for routing configuration.</p> <p>Although in many cases it might be used through the CDN, it's still recommended to use still-cli for basics setup and component creation since this is an automatical way to create components and handle the routing. </p>"},{"location":"lone-component/#microfrontend","title":"Microfrontend","text":"<p>Lone component also provides with the capabilities to build a whole Frontend tied to an entrypoint component thereby making it possible to scale it to Microfrontend.</p> <p> </p>"},{"location":"lone-component/#1-basic-lone-component-application-tutorial","title":"1. Basic Lone component application tutorial","text":""},{"location":"lone-component/#-simple-project-folder-structure","title":"- Simple project folder structure","text":"<p>The bellow folder structure is only an example which can also be taken as suggestion, anyway the most important files are the <code>app/</code> folder and <code>route.map.js</code> file.</p> <pre><code>    project-name #My project root folder\n    |___ microfrontend/ #This is a folder where all microfrontends will be placed\n    |     |__ still/ #This folder contanins the microfrontends implementations in Still.js\n    |     |    |__ app/ #App folder where component will be placed\n    |     |    |    |__ components/ #Folder which holds the comopnents\n    |     |    |    |    |__ dummy/ #Folder which holds the comopnents\n    |     |    |    |    |    |__ DummyComponent.js #Created in the point 1.4\n    |     |    |    |    |__ another/ #Will house components concerning to the user\n    |     |    |__ config/ #App folder where component will be placed\n    |     |    |    |__ route.map.js #still-cli will add the route automatically when creating a component\n    |     | \n    #Bellow are the files of my project placed in the project root folder\n    |__ index.html\n    |__ my-project-folder/\n    |__ ... #Additional files from my project\n</code></pre>"},{"location":"lone-component/#code-editoride-view","title":"Code editor/IDE view:","text":""},{"location":"lone-component/#11-setup-generating-base-files-app-routemapjs-for-lone-components-to-work","title":"1.1 Setup - Generating base files (app/, route.map.js) for Lone components to work","text":"<p>From inside the folder where we want to have our Lone components, using the still-cli we have to run the following:</p> <pre><code>npx still lone\n</code></pre> <p></p>"},{"location":"lone-component/#12-adding-the-cdn-and-embeding-the-component-to-the-html-file","title":"1.2 Adding the CDN and embeding the component to the HTML file","text":"<p>index.html file is being used in this case, but it can just be done in any  type of file that will render something to the browser.</p> index.html <pre><code>&lt;!DOCTYPE html&gt;\n&lt;html lang=\"en\"&gt;\n\n&lt;head&gt;\n    &lt;meta charset=\"UTF-8\"&gt;\n    &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=Edge\"&gt;\n    &lt;meta content=\"width=device-width, initial-scale=1\" name=\"viewport\" /&gt;\n    &lt;title&gt;StillJS&lt;/title&gt;\n    &lt;!-- Bellow (STILL_HOME) is the Still env variable to inform where to look for components --&gt;\n    &lt;script&gt; STILL_HOME = 'microfrontend/still/' &lt;/script&gt;\n    &lt;!-- Bellow both JavaScript and CSS CDN inclusion, JS type neeeds to module --&gt;\n    &lt;link href=\"https://cdn.jsdelivr.net/npm/@stilljs/core@latest/@still/ui/css/still.css\" rel=\"stylesheet\"&gt;\n    &lt;script src=\"https://cdn.jsdelivr.net/npm/@stilljs/core@latest/@still/lone.js\" type=\"module\"&gt;&lt;/script&gt;\n&lt;/head&gt;\n\n&lt;body&gt;\n    &lt;div&gt;\n        This is My HTML regular content nothing to do with Still.js\n        &lt;!-- Bellow component (DummyComponent) will be created step (step 1.4) --&gt;\n        &lt;st-element component=\"DummyComponent\"&gt;&lt;/st-element&gt;\n    &lt;/div&gt;\n&lt;/body&gt;\n</code></pre> <p>Our application file is required to set the <code>STILL_HOME</code> variable which needs to point to the root folder where the still project is located, as this is how the framework knows how to bring components to our application.</p> <p></p> <p></p>"},{"location":"lone-component/#13-running-my-application","title":"1.3 Running my Application","text":"<p>In order for the components to load properly the Application needs to be served from a web server, it can be NGINX or Apache for example, in this case, we'll use live-server. Using live-server we need to do it from the root folder:</p> <p></p> Expand to show Lone component running success <p></p> <p></p>"},{"location":"lone-component/#14-creating-the-lone-component-whithin-cdn-base-project","title":"1.4 Creating the Lone component Whithin CDN base project","text":"<p>Let's create our Lone component based on the folder structure presented previously (point 1.1), from the root folder where still is located and use abbreviated still-cli command option.</p> <p></p> <p>When creating a Lone component in the CDN context, we need to pass the <code>--lone</code> at the end, as this is how still understands that the whole structure and files are not present locally.</p> <p>Once generated, the component should have the scaffolding code as follows:  </p> DummyComponent.js <pre><code>export class DummyComponent extends ViewComponent {\n\n    isPublic = true;\n    template = `\n        &lt;h1 class=\"still-fresh-generated-cmp\"&gt;\n            DummyComponent  auto generated content\n        &lt;/h1&gt;\n    `;\n\n    constructor(){\n        super();\n    }\n\n}\n</code></pre> <p>In this case the <code>ViewComponent</code> super class is not imported dispite being extended, this is because CDN provides it since it is not present locally.</p> <p></p>"},{"location":"lone-component/#2-lone-component-by-having-whole-framework-structure-locally","title":"2. Lone component by having whole framework Structure locally","text":""},{"location":"lone-component/#context","title":"Context","text":"<p>Lone component can also be created in the scenario where I have create a regular Still.js project, however for a specific situation I need a component which can be embeded to my other type (not Still.js) of Application.</p>"},{"location":"lone-component/#user-case","title":"User case","text":"<p>This could be a good use case where I have more than one application or where some of the resources would be shared between my Lone component and another Still.js Application I have.</p> <p></p>"},{"location":"lone-component/#21-folder-structure","title":"2.1 Folder Structure","text":"<p>The big different between this approach vs using CDN approach is that we have the whole Still.js folder structure and files locally, but how HTML/main application file(s) will always stay outside since Still.js components will only be embeded but not dictate the application flow itself.</p> <p>The HTML/Application file in this case will point to the local files instead of the CDN ones, follow the code sample:</p> <p></p>"},{"location":"lone-component/#13-adding-the-cdn-and-embeding-the-component-to-the-html-file","title":"1.3 Adding the CDN and embeding the component to the HTML file","text":"index.html <pre><code>&lt;!DOCTYPE html&gt;\n&lt;html lang=\"en\"&gt;\n\n&lt;head&gt;\n    &lt;meta charset=\"UTF-8\"&gt;\n    &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=Edge\"&gt;\n    &lt;meta content=\"width=device-width, initial-scale=1\" name=\"viewport\" /&gt;\n    &lt;title&gt;StillJS&lt;/title&gt;\n    &lt;!-- Bellow (STILL_HOME) is the Still env variable to inform where to look for components --&gt;\n    &lt;script&gt; STILL_HOME = 'micro/still/' &lt;/script&gt;\n    &lt;!-- Since the Still.js files are present locally we point to it instead of the CDN --&gt;\n    &lt;link href=\"micro/still/@still/ui/css/still.css\" rel=\"stylesheet\"&gt;\n    &lt;script src=\"micro/still/@still/lone.js\" type=\"module\"&gt;&lt;/script&gt;\n&lt;/head&gt;\n\n&lt;body&gt;\n\n    &lt;div&gt;\n        This is a regular HTML page, let's test the Lone component\n        feature in Still.js and\n        &lt;!-- Bellow component (DummyComponent) need to be created as in the point (1.2) --&gt;\n        &lt;st-element component=\"DummyComponent\"&gt;&lt;/st-element&gt;\n    &lt;/div&gt;\n\n&lt;/body&gt;\n</code></pre> <p>Component creation consideration</p> <p>Unlike the CDN scenario, we don't have to use the <code>--lone</code> option when creating Lone component having the whole Still.js folder structure and files.</p> <p>Once the Still.js setup is done for our application, we then need to run it, in this case the process will be the same as point 1.5.</p> <p></p> <p>Microfrontend considerations</p> <p>Although Lone Components don't run within the Still.js Application container, they still support all core framework features \u2014 like reactivity, services, routing, authorization, etc. \u2014 making them suitable for a Microfrontend architecture.</p>"},{"location":"playground/","title":"Code Editor Example","text":"// Write your JavaScript code here..."},{"location":"routing/","title":"ROUTING & NAVIGATION","text":""},{"location":"routing/#stilljs-routing-and-router-object","title":"Still.js Routing and Router Object","text":""},{"location":"routing/#overview","title":"Overview","text":"<p>Unlike some other framerowkrs Still.js has a built-in navitation capabilities, basically it provides with a different was of addressing it from basically jumping from one component/page to another to a more robust use cases such as passing data when navigating and URL navigation. By default the navigation won't reflect the URL in the browser navigation bar, for that we need to pass the URL para as true.</p> <p>All Routing capabilities in the Framework is provided by the Router Helper/Object, it taks care of data passing, handles route name and url.</p> <p>Component metadata for navigation is provided through the <code>route.map.js</code> file, it contains three data for each component, such metadata is added automatically when component is created using still-cli (see here), and eache component metadata has the format as follow:</p> <p><pre><code>{\n    RouteName: { path: 'path/to-the/component/folder/', url: '/component-url' }\n}\n</code></pre> </p> <ul> <li> <p>Route name - A component's name, used for navigation, must be unique across the project (except for vendor components) and cannot be changed unless the component itself is renamed.</p> </li> <li> <p>path - It's the folder path where the component is located and cannot be changed unless the component is physically moved to a different folder.</p> </li> <li> <p>url - It can be used in the browser navigation bar or in a regular HTML link, it can be changed as per the dev will.</p> </li> </ul> <p></p> <p>Throughout this documentation/tutorial taking into consideration the component that will be represented, the Routing file (<code>route.map.js</code>), the project structure and the <code>app-setup.js</code> will be set as shown bellow, in <code>app-setup.js</code> we set the <code>MainMenuComponent</code> as first loading component:</p> route.map.jsroute.map.js Project folder structure Application Setup stating MainMenuComponent as the first component to load<pre><code>import { StillAppMixin } from \"./@still/component/super/AppMixin.js\";\nimport { Components } from \"./@still/setup/components.js\";\nimport { AppTemplate } from \"./app-template.js\";\nimport { MainMenuComponent } from \"./app/navigation/MainMenuComponent.js\";\n\nexport class StillAppSetup extends StillAppMixin(Components) {\n\n    constructor() {\n        super();\n        this.setHomeComponent(MainMenuComponent); //This will be the first component to be loaded\n    }\n\n    async init() {\n        return await AppTemplate.newApp();\n    }\n\n}\n</code></pre> Routing mapping file which resides in the project root folder<pre><code>export const stillRoutesMap = {\n    viewRoutes: {\n        regular: {\n            /** HomeComponent won't be used, but this is generated automatically \n             * when starting the project */\n            HomeComponent: {\n                path: \"app/home\",\n                url: \"/HomeComponent\"\n            },\n            MainMenuComponent: {\n                path: \"app/navigation\",\n                url: \"/main-menu\"\n            },\n            PersonForm: {\n                path: \"app/person\",\n                url: \"/person/register\"\n            },\n            PersonList: {\n                path: \"app/person\",\n                url: \"/person/list\"\n            }\n        },\n        lazyInitial: {}\n    }\n}\n</code></pre> Project folder structure<pre><code>project-root-folder\n|__ @still/\n|__ app/\n|    |\n|    |__ navigation/ #-&gt; This is component folder\n|    |   |__ MainMenuComponent.js\n|    |   |\n|    |__ person/ #-&gt; This is component folder\n|    |   |__ PersonForm.js\n|    |   |__ PersonList.js\n|    |   |\n|__ config/\n|    |__ app-setup.js\n|    |__ route.map.js\n|__  ... #-&gt; Remaining files\n</code></pre> <p>Routes generation and management </p> <p>When using still-cli to generate the components, routes are added automatically as well as the component name conflicts is checked, also, it's not recommended at all to generate components manually.</p> <p></p>"},{"location":"routing/#navigation-using-goto-in-the-click-directive-event","title":"Navigation using goto in the <code>(click)</code> directive event","text":"<p>This example takes into consideration the route mapping file and folder structure defined above.</p> <p>In addition to allow component method binding, the <code>(click)</code> directive also has a capability to provide navigation withouth any method binding, as only <code>goto()</code> is needed to be specified, ans pass the Route name.</p> MainMenuComponent.jsPersonList.jsPersonForm.js Using goto() with (click) directive to navigate to another component/page<pre><code>import { ViewComponent } from \"../../@still/component/super/ViewComponent.js\";\n\nexport class MainMenuComponent extends ViewComponent {\n\n    isPublic = true;\n    template = `\n        &lt;div&gt;\n            This is the main menu, Select Your desired option\n            &lt;div&gt;\n                &lt;button (click)=\"goto('PersonForm')\"&gt;Register new Person&lt;/button&gt;\n                &lt;button (click)=\"goto('PersonList')\"&gt;List Persons&lt;/button&gt;\n            &lt;/div&gt;\n        &lt;/div&gt;\n    `;\n}\n</code></pre> Main menu has navigation to here, and vice-versa<pre><code>import { ViewComponent } from \"../../@still/component/super/ViewComponent.js\";\n\nexport class PersonList extends ViewComponent {\n\n    isPublic = true;\n    template = `\n        &lt;h1 class=\"still-fresh-generated-cmp\"&gt;\n            &lt;p&gt;\n                Here will be the list previous registered persons\n            &lt;/p&gt;\n            &lt;button (click)=\"goto('MainMenuComponent')\"&gt;Go to main menu&lt;/button&gt;\n        &lt;/h1&gt;\n    `;\n\n}\n</code></pre> Main menu has navigation to here, and vice-versa<pre><code>import { ViewComponent } from \"../../@still/component/super/ViewComponent.js\";\n\nexport class PersonForm extends ViewComponent {\n\n    isPublic = true;\n    template = `\n        &lt;h1 class=\"still-fresh-generated-cmp\"&gt;\n            &lt;p&gt;\n                Showing Person registration form in here\n            &lt;/p&gt;\n            &lt;button (click)=\"goto('MainMenuComponent')\"&gt;Go to main menu&lt;/button&gt;\n        &lt;/h1&gt;\n    `;\n\n}\n</code></pre> <p>This is simple navigation approach, where only it's needed to go from one component/page to another, anyway, more powerfull navigation is possible using the same directive.</p> <p> </p> <p></p>"},{"location":"routing/#passing-data-from-component-to-component-when-navigating-using-goto","title":"Passing Data from Component to Component when navigating using <code>goto()</code>","text":"<p>This example takes into consideration the route mapping file and folder structure defined above.</p> MainMenuComponent.jsPersonList.jsPersonForm.js Passing Data to the target component to be navigated to<pre><code>import { ViewComponent } from \"../../@still/component/super/ViewComponent.js\";\n\nexport class MainMenuComponent extends ViewComponent {\n\n    isPublic = true;\n\n    /** Value of this property will be send to PersonForm when navigating\n     * it could either be a state (no annotation), would work the same was\n     * @Prop \n     * */\n    complexData = {\n        name: 'Mayor', skills: 'Programming'\n    };\n\n    template = `\n        &lt;div&gt;\n            This is the main menu, Select Your desired option\n            &lt;div&gt;\n                &lt;button \n                    (click)=\"goto('PersonForm', self.complexData)\"\n                &gt;Register new Person&lt;/button&gt;\n                &lt;button \n                    (click)=\"goto('PersonList', 'A simple string')\"\n                &gt;List Persons&lt;/button&gt;\n            &lt;/div&gt;\n        &lt;/div&gt;\n    `;\n}\n</code></pre> Main menu has navigation to here, and vice-versa<pre><code>import { ViewComponent } from \"../../@still/component/super/ViewComponent.js\";\nimport { Router } from \"../../@still/routing/router.js\";\n\nexport class PersonList extends ViewComponent {\n\n    isPublic = true;\n\n    //This is a state which reactively \n    //updates in case its value gets changed\n    myText = null;\n\n    template = `\n        &lt;h1 class=\"still-fresh-generated-cmp\"&gt;\n            &lt;p&gt;Here will be the list previous registered persons. State binding bellow:&lt;/p&gt;\n            &lt;p&gt;@myText&lt;/p&gt;\n            &lt;button (click)=\"goto('MainMenuComponent')\"&gt;Go to main menu&lt;/button&gt;\n        &lt;/h1&gt;\n    `;\n\n    stOnRender() {\n        //Retrieve the data by using the Router helper\n        this.myText = Router.data(this);\n    }\n}\n</code></pre> Main menu has navigation to here, and vice-versa<pre><code>import { ViewComponent } from \"../../@still/component/super/ViewComponent.js\";\nimport { Router } from \"../../@still/routing/router.js\";\n\nexport class PersonForm extends ViewComponent {\n\n    isPublic = true;\n\n    myObjectState = null;\n\n    template = `\n        &lt;h1 class=\"still-fresh-generated-cmp\"&gt;\n            &lt;p&gt;\n                Showing Person registration form in here, State binding bellow:\n            &lt;/p&gt;\n            &lt;p&gt;@myObjectState&lt;/p&gt;\n            &lt;button (click)=\"goto('MainMenuComponent')\"&gt;Go to main menu&lt;/button&gt;\n        &lt;/h1&gt;\n    `;\n\n    stAfterInit() {\n        const myData = Router.data(this);\n        /** Because data is JSON object we're stringifying \n         * reactively to print it in the page */\n        this.myObjectState = JSON.stringify(myData);\n    }\n}\n</code></pre> <p>MainMenuComponent - 2 scenarios are in place, first (line 20) we're passing a complex data structure to another component by navigation, hence we need to assign to a variable (state or prop) in the component. The second scenario (line 23), we're just passing a string, hence we only need to enclose it in single quotation mark.</p> <p>PersonList Used state variable for reactive template binding. Data is fetched using the Router helper, which requires the target object as input. <code>stOnRender()</code> hook triggers this process when the component is rendering.</p> <p>PersonForm Used state variable for reactive template binding. in this case, because Data is a JSON object, it's being stringified before assignment. <code>stAfterInit()</code> hook triggers  when the component is rendered.</p> <p> </p> <p></p>"},{"location":"routing/#router-helper-routing-inside-a-business-logicmethod","title":"Router Helper - Routing inside a Business logic/Method","text":"<p>This example takes into consideration the route mapping file and folder structure defined above.</p> MainMenuComponent.jsPersonForm.js Navigation whith business logic implemented with Router Helper<pre><code>import { ViewComponent } from \"../../@still/component/super/ViewComponent.js\";\nimport { Router } from \"../../@still/routing/router.js\";\n\nexport class MainMenuComponent extends ViewComponent {\n\n    isPublic = true;\n\n    template = `\n        &lt;div&gt;\n            This is the main menu, Select Your desired option\n            &lt;div&gt;\n                &lt;button (click)=\"registerPerson()\"&gt;Register new Person&lt;/button&gt;\n            &lt;/div&gt;\n        &lt;/div&gt;\n    `;\n\n    registerPerson() {\n        const myValidation = true;\n        if (myValidation) {\n            //Data (2nd param) can be of any type (object, string, number, array, etc.)\n            Router.goto('PersonForm', { data: { name: 'Dany', skills: 'None' } });\n        } else {\n            Router.goto('PersonForm');\n        }\n    }\n}\n</code></pre> Main menu has navigation to here, and vice-versa<pre><code>import { ViewComponent } from \"../../@still/component/super/ViewComponent.js\";\nimport { Router } from \"../../@still/routing/router.js\";\n\nexport class PersonForm extends ViewComponent {\n\n    isPublic = true;\n\n    myObjectState = null;\n\n    template = `\n        &lt;h1 class=\"still-fresh-generated-cmp\"&gt;\n            &lt;p&gt;\n                Showing Person registration form in here, State binding bellow:\n            &lt;/p&gt;\n            &lt;p&gt;@myObjectState&lt;/p&gt;\n            &lt;button (click)=\"goto('MainMenuComponent')\"&gt;Go to main menu&lt;/button&gt;\n        &lt;/h1&gt;\n    `;\n\n    stAfterInit() {\n        const myData = Router.data(this);\n        /** Because data is JSON object we're stringifying \n         * reactively to print it in the page */\n        this.myObjectState = JSON.stringify(myData);\n    }\n}\n</code></pre> <p>MainMenuComponent - We've implemented a method which uses the Route helper for navigation through the <code>.goto()</code>. Unlike the (click) directive, the goto through the Helper recieves an object as second parameter, this object has varios properties, and data can be of any type.</p> <p>PersonForm Used state variable for reactive template binding. in this case, because Data is a JSON object, it's being stringified before assignment. <code>stAfterInit()</code> hook triggers  when the component is rendered.</p> <p></p>"},{"location":"routing/#router-helper-within-lone-component","title":"Router Helper within Lone component","text":"<p>This example takes into consideration the route mapping file and folder structure defined above.</p> <p>When it comes to Microfrontend, there might be a situation where more than one Still.js microfronted is present, for this reason, when dealing with navigation it's important for the Router to know which frontend should be affected.</p> MainMenuComponent.jsPersonForm.js Passing the serviceId event when it comes to using Router in Lone component context<pre><code>import { ViewComponent } from \"../../@still/component/super/ViewComponent.js\";\nimport { Router } from \"../../@still/routing/router.js\";\n\nexport class MainMenuComponent extends ViewComponent {\n\n    isPublic = true;\n\n\n    template = `\n        &lt;div&gt;\n            This is the main menu, Select Your desired option\n            &lt;div&gt;\n                &lt;button (click)=\"registerPerson()\"&gt;Register new Person&lt;/button&gt;\n            &lt;/div&gt;\n        &lt;/div&gt;\n    `;\n\n    registerPerson() {\n        const myValidation = true;\n        if (myValidation) {\n            Router.goto('PersonForm', {\n                data: { name: 'Dany', skills: 'None' },\n                evt: Router.serviceId\n            });\n        } else {\n            Router.goto('PersonForm');\n        }\n    }\n}\n</code></pre> Main menu has navigation to here, and vice-versa<pre><code>import { ViewComponent } from \"../../@still/component/super/ViewComponent.js\";\nimport { Router } from \"../../@still/routing/router.js\";\n\nexport class PersonForm extends ViewComponent {\n\n    isPublic = true;\n\n    myObjectState = null;\n\n    template = `\n        &lt;h1 class=\"still-fresh-generated-cmp\"&gt;\n            &lt;p&gt;\n                Showing Person registration form in here, State binding bellow:\n            &lt;/p&gt;\n            &lt;p&gt;@myObjectState&lt;/p&gt;\n            &lt;button (click)=\"goto('MainMenuComponent')\"&gt;Go to main menu&lt;/button&gt;\n        &lt;/h1&gt;\n    `;\n\n    stAfterInit() {\n        const myData = Router.data(this);\n        /** Because data is JSON object we're stringifying \n         * reactively to print it in the page */\n        this.myObjectState = JSON.stringify(myData);\n    }\n}\n</code></pre> <p>To specify which microservice is triggering the navigation, we just need to pass the <code>evt</code> property (line 23) in the second parameter which is assigned with serviceId from Router helpr, this id is generated and managed internally by the Router itself, we're just informing that the navigation event it triggered from such service.</p> <p>ServiceId without Router Helper</p> <p>When using the <code>goto()</code> with the <code>(click)</code> directive we don't need to inform the serviceId as it's taken care automatically by the router helper.</p> <p></p>"},{"location":"routing/#making-navigation-reflect-the-browser-url-in-navigation-bar","title":"Making navigation reflect the browser URL in navigation Bar","text":"<p>As depicted above, by default the navigation won't reflect the in the browser URL, anyway, in both scenarios (using <code>goto()</code> in the <code>(click)</code> directive - see here) as well as (<code>Router Helper</code> - see here), we can instruct the Router to put the URL by passing url parameter as true, as follow:</p> <ul> <li> <p>goto() with (click) directive - it will be <code>goto('RouteName','Data',true)</code>, where url param is the 3rd pararmeter, and data can be passed as null if not needed.</p> </li> <li> <p>Router Helper - It'll be <code>Router.goto('RouteName', {url: true})</code>, and as shown in the Router Helper example data can be passed as a property of a second parameter along with the url flag.</p> </li> </ul> <p></p>"},{"location":"routing/#using-the-url-defined-in-the-routemapjs","title":"Using the URL defined in the <code>route.map.js</code>","text":"<p>This example takes into consideration the route mapping file and folder structure defined above.</p> <p>Regular URL navigaition is in place through the component mapped URL, however, as of now it does not support data passing, this capability will be provided in the future. Follow the example:</p> MainMenuComponent.jsPersonForm.js Navigates to another component by using its url<pre><code>import { ViewComponent } from \"../../@still/component/super/ViewComponent.js\";\n\nexport class MainMenuComponent extends ViewComponent {\n\n    isPublic = true;\n\n    template = `\n        &lt;div&gt;\n            This is the main menu, Select Your desired option\n            &lt;div&gt;\n                &lt;a href=\"#/person/register\"&gt;Register new Person&lt;/a&gt;\n            &lt;/div&gt;\n        &lt;/div&gt;\n    `;\n}\n</code></pre> Goes back to MainMenu by using its url<pre><code>import { ViewComponent } from \"../../@still/component/super/ViewComponent.js\";\n\nexport class PersonForm extends ViewComponent {\n\n    isPublic = true;\n    template = `\n        &lt;h1 class=\"still-fresh-generated-cmp\"&gt;\n            &lt;p&gt;\n                Showing Person registration form in here\n            &lt;/p&gt;\n            &lt;a href=\"#/main-menu\"&gt;Go to main menu&lt;/a&gt;\n        &lt;/h1&gt;\n    `;\n\n}\n</code></pre> <p>Navigation via URL requires the usage of the HTML link (&lt;a&gt;) tag, and the URL needs to be prefixed with hash (#) character when assigning the url in the <code>href</code>.</p> <p></p>"},{"location":"routing/#enjoy-your-navigations","title":"Enjoy your navigations!","text":""},{"location":"still-cli/","title":"STILL CLI","text":""},{"location":"still-cli/#overview","title":"Overview","text":"<p><code>still-cli</code> is a Still framework tool which makes it easy to handle some of the recurrent and specific tasks (e.g. Development tasks phase) thereby helping to speed up the things in certain aspects.</p> <p>Initially the CLI tool provides commands in 3 categories such as Application, Component and Routing, in this documentation, we'll summarize the focusing in the more recurrent and key command.</p> <p>Once install CLI tools goes by <code>stilljs</code>, however it can be abreviated by <code>stilljs</code> or <code>st</code>. Just like the tool, the commands (e.g. create, route) and parameters (e.g. list) are also available through alias as can be seen when typing <code>still --help</code>.</p> <p>Windows considerations</p> <p>When using the CLI tool on Windows it might happen that the the installetion does not get identified in the path right after, in this case it can be used with npx prefix (e.g. <code>npx still create component path/to-my/MyComponent</code>)</p> <p></p>"},{"location":"still-cli/#installation","title":"Installation","text":"<p>Still CLI tool is provided through the NPM (Node Package Manager), and it has to be installed globally and not in a project scope:</p> <pre><code>npm install @stilljs/cli -g\n</code></pre> <p></p>"},{"location":"still-cli/#create-a-new-project","title":"Create a new project","text":"<p>In order to create a new project we have to have a folder in which we want the project to be, and inside this project I'll run the init command. <pre><code>// Bellow command needs to be ran from inside the project folder\nstill init\n</code></pre></p> <p></p> <p></p>"},{"location":"still-cli/#component-creation","title":"Component Creation","text":"<p>It's recommended to use the CLI tool when creating a component in Still, as this will not only generate the new component but also manage conflicts and routes. </p> <p>When creating a component, we have to specify the path, if folders of the path exists only the component will be created, otherwise both folder(s) and component will be created. <pre><code>still create component app/components/user/UserListComponent\n</code></pre></p> <p></p> <p>Folder structure changes</p> <p>The folder structures in this images correspond the old Still.js setup. In the new setup there if the config folder which holds <code>app-setup.js</code>, <code>app-template.js</code> and <code>route.map.js</code></p> <p>Lone component creation</p> <p>Lone component takes place in the use case where we're creating a Microfrontend or using Still.js framework through the CDN, therefore when creating a component in this context we need to specify the <code>--lone</code> flag in the end. (e.g. <code>npx still create component path/to-my/MyComponent --lone</code>)</p> <p></p>"},{"location":"still-cli/#listing-routes","title":"Listing routes","text":"<p>Routes is one of the core aspects of Still.js framework (check routing &amp; navgation), hence they are generate automatically when a component is created, and we can check on them also by using the CLI tool. <pre><code>// Bellow command needs to be ran from inside the project folder\nstill route list\n</code></pre></p> <p></p> <p>Folder structure changes</p> <p>The folder structures in this images correspond the old Still.js setup. In the new setup there if the config folder which holds <code>app-setup.js</code>, <code>app-template.js</code> and <code>route.map.js</code></p> <p> </p>"},{"location":"template-logic/","title":"TEMPLATE BUSINESS LOGIC","text":""},{"location":"template-logic/#overview","title":"Overview","text":"<p>As of version 1.3.0, Still.js supports template logic, allowing developers to control application flow directly in templates using <code>@for</code>, <code>@if</code>, or inline expressions like <code>${ 'Five plus six is ' + (5 + 6) }</code>.</p>"},{"location":"template-logic/#what-youll-learn","title":"What you'll learn?","text":"<ol> <li>Looping through a list using <code>@for</code>     a. Nested looping     b. Trace the loop index     c. Pass another component in the loop     d. Use condition to control the loop output</li> <li>Conditional rendering of the <code>@for</code> content without reactive effect (top-level <code>@if</code>)</li> <li>Keep reactive effect while conditional rendering of the <code>@for</code> content (with <code>(showIf)</code>)</li> <li>Top Level conditional (<code>@if</code>).</li> <li>Conditional CSS formatting.</li> </ol>"},{"location":"template-logic/#in-template-looping-with-for-and-endfor-for","title":"In template Looping with <code>@for and @endfor (for)</code>:","text":"<p>Supports nesting loops allowing to handle complex data structures and presenting data in a customized way.</p> <p>The comming examples will be based in the following project structure:</p> <pre><code>project-root-folder\n|__ @still/\n|__ app/\n|    |\n|    |__ components/ #-&gt; This is component folder\n|    |   |__ OrganizationHierarchy.js\n|    |   |__ OrganizationHierarchy.html\n|    |   |__ organization-data.js\n|    |   |\n|__ config/\n|    |__ app-setup.js\n|    |__ route.map.js\n|__  ... #-&gt; Remaining files\n</code></pre> organization-data.jsOrganizationHierarchy.jsOrganizationHierarchy.html Data<pre><code>export const organizationData = [\n    {\n    \"title\": \"Chief Executive Officer\",\n    \"children\": [ {\n        \"title\": \"Vice President of Engineering\",\n        \"children\": [ {\n            \"title\": \"Engineering Manager\",\n            \"children\": [\n                {\"title\": \"Senior Software Engineer\"},\n                {\"title\": \"Software Engineer\"}\n            ]\n            },\n            {\n            \"title\": \"Senior Engineering Manager\",\n            \"children\": [ {\"title\": \"Quality Assurance Engineer\"} ]\n            }\n        ]\n        },\n        {\n        \"title\": \"Vice President of Marketing\",\n        \"children\": [ {\n            \"title\": \"Marketing Manager\",\n            \"children\": [ {\"title\": \"Marketing Specialist\"} ]\n            }\n        ]\n        }]\n    }\n];\n</code></pre> Component<pre><code>import { ViewComponent } from \"../../@still/component/super/ViewComponent.js\";\nimport { ListState } from \"../../@still/component/type/ComponentType.js\";\nimport { organizationData } from \"./organization-data.js\";\n\nexport class OrganizationHierarchy extends ViewComponent {\n\n    isPublic = true;\n\n    // Data is coming from a js file, but could be API\n    // ListState type is convinient for better experience\n    /** @type { ListState&lt;Array&gt; } */\n    rolesList = organizationData;\n\n}\n</code></pre> Template<pre><code>&lt;div style=\"padding: 20px;\"&gt;\n  &lt;ul&gt;\n    @for(role in this.rolesList)\n      &lt;li&gt;\n        {role.title}\n        &lt;ul style=\"margin-left: 15px;\"&gt;\n          @for(subRole in role.children)\n            &lt;li&gt;\n              {subRole.title}\n              &lt;ul style=\"margin-left: 15px;\"&gt;\n                @for(subSubRole in subRole.children)\n                  &lt;li&gt;{subSubRole.title}&lt;/li&gt;\n                @endfor\n              &lt;/ul&gt;\n            &lt;/li&gt;    \n          @endfor\n        &lt;/ul&gt;\n      &lt;/li&gt;\n    @endfor\n  &lt;/ul&gt;\n&lt;/div&gt;\n</code></pre> <p>Result:</p> <p></p> <p>The example loops through a tree structure (from a file, could be API), printing items at each level. The outer most (first) <code>@for</code> references a component variable, so <code>this.</code> is required.</p>"},{"location":"template-logic/#fetching-from-api-consideration","title":"Fetching from API consideration","text":"<p>Warning</p> <p>When data is being fetched from the API, the state variables (list) needs to be initialized with a empty array ([]), in this case it would be as follow: <pre><code>    /** @type { ListState&lt;Array&gt; } */\n    rolesList = [];\n</code></pre></p> <p></p>"},{"location":"template-logic/#looping-using-for-with-conditional-if","title":"Looping using @for with conditional (@if)","text":"<p>We can also use conditional (<code>@if</code>) while looping with <code>@for</code>, follow the bellow example (between lines 12 and 14):</p> OrganizationHierarchy.html Template<pre><code>&lt;div style=\"padding: 20px;\"&gt;\n  &lt;ul&gt;\n    @for(role in this.rolesList)\n      &lt;li&gt;\n        {role.title}\n        &lt;ul style=\"margin-left: 15px;\"&gt;\n          @for(subRole in role.children)\n            &lt;li&gt;\n            {subRole.title}\n              &lt;ul style=\"margin-left: 15px;\"&gt;\n                @for(subSubRole in subRole.children)\n                  @if(subSubRole.title.indexOf('Manager') &lt; 0)\n                    &lt;li&gt;{subSubRole.title}&lt;/li&gt;\n                  @endif\n                @endfor\n              &lt;/ul&gt;\n            &lt;/li&gt;   \n          @endfor\n        &lt;/ul&gt;\n      &lt;/li&gt;\n    @endfor\n  &lt;/ul&gt;\n&lt;/div&gt;\n</code></pre> <p>Result:</p> <p></p> <p>In the above case, from the template we're adding a condition to print only those roles that not contains Manager for the third hierarchy level.</p> <p> </p>"},{"location":"template-logic/#getting-the-record-index-out-of-the-loop","title":"Getting the record Index out of the loop","text":"<p>It's also get the index of the <code>@for</code> loop, we have to assign the <code>$count</code> constant to the variables name that will be used to trace the indexes.</p> OrganizationHierarchy.html Template<pre><code>&lt;div style=\"padding: 20px;\"&gt;\n  &lt;ul&gt;\n    @for(role in this.rolesList; idx = $count)\n    &lt;li&gt;\n      {idx} - {role.title}\n      &lt;ul style=\"margin-left: 15px;\"&gt;\n        @for(subRole in role.children; idx1 = $count)\n          &lt;li&gt;\n            {idx1} - {subRole.title}\n            &lt;ul style=\"margin-left: 15px;\"&gt;\n              @for(subSubRole in subRole.children)\n                &lt;li&gt;{subSubRole.title}&lt;/li&gt;\n              @endfor\n            &lt;/ul&gt;\n          &lt;/li&gt;    \n        @endfor\n      &lt;/ul&gt;\n    &lt;/li&gt;\n    @endfor\n  &lt;/ul&gt;\n&lt;/div&gt;\n</code></pre> <p> </p>"},{"location":"template-logic/#passing-another-component-inside-the-loop","title":"Passing another component inside the loop","text":"<p>Like the (forEach) directive, we can pass another component inside the loop.</p> OrganizationHierarchy.htmlManagedTeam.js + embedded template Template<pre><code>&lt;div style=\"padding: 20px;\"&gt;\n  &lt;ul&gt;\n    @for(role in this.rolesList)\n      &lt;li&gt;\n        {role.title}\n        &lt;ul style=\"margin-left: 15px;\"&gt;\n          @for(subRole in role.children)\n            &lt;li&gt;\n              {subRole.title}\n              &lt;!-- \n                We scalar (e.g. String, number) property one by one\n                or we can pass a complex structure (json, array) as item \n              --&gt;\n              &lt;st-element \n                  component=\"ManagedTeam\" \n                  item=\"{subRole}\"&gt;\n              &lt;/st-element&gt;\n            &lt;/li&gt;  \n          @endfor\n        &lt;/ul&gt;\n      &lt;/li&gt;\n    @endfor\n  &lt;/ul&gt;\n&lt;/div&gt;\n</code></pre> Template<pre><code>import { ViewComponent } from \"../../@still/component/super/ViewComponent.js\";\n\nexport class ManagedTeam extends ViewComponent {\n\n    isPublic = true;\n\n    // The bellow state variable maps from the passed\n    // item (item=\"{subRole}\") which is subRole JSON object \n    children;\n\n    template = `\n        &lt;ul style=\"margin-left: 15px;\"&gt;\n          @for(role in this.children)\n              &lt;li style=\"color: green;\"&gt;{role.title}&lt;/li&gt;\n          @endfor\n        &lt;/ul&gt;\n    `;\n}\n</code></pre> <p>Result:</p> <p></p> <p></p>"},{"location":"template-logic/#conditional-formating-and-defining-each-loop-output-id-to-leverage-partial-dom-update","title":"Conditional formating and Defining each loop output id to leverage Partial DOM update","text":"<p>Partial dom update will happen through the top-most item of the for loop even when in nesting loop scenario, then this is where we need to set the id.</p> <p>The id should be unique for each item, it needs to come from the data, not from the index. the field name needs to be id.</p> OrganizationHierarchy.htmlOrganizationHierarchy.js + data Template<pre><code>&lt;div style=\"padding: 20px;\"&gt;\n\n  &lt;button (click)=\"updateRole()\"&gt;Update role&lt;/button&gt;\n  &lt;ul&gt;\n    @for(role in this.rolesList)\n      &lt;li id=\"{role.id}\"&gt;\n        {role.title}\n        &lt;ul style=\"margin-left: 15px;\"&gt;\n          @for(subRole in role.children)\n          &lt;li&gt;\n            {subRole.title}\n            &lt;ul style=\"margin-left: 15px;\"&gt;\n              @for(subSubRole in subRole.children)\n                &lt;!-- Bellow we're setting the text color conditionally --&gt;\n                &lt;li style=\"color: { subSubRole.title.indexOf('Senior') &gt;= 0 ? 'green' : '' }\"&gt;\n                  {subSubRole.title}\n                &lt;/li&gt;\n              @endfor\n            &lt;/ul&gt;\n          &lt;/li&gt;  \n          @endfor\n        &lt;/ul&gt;\n      &lt;/li&gt;\n    @endfor\n  &lt;/ul&gt;\n\n&lt;/div&gt;\n</code></pre> Template<pre><code>import { ViewComponent } from \"../../@still/component/super/ViewComponent.js\";\nimport { ListState } from \"../../@still/component/type/ComponentType.js\";\nimport { organizationData } from \"./organization-data.js\";\n\nexport class OrganizationHierarchy extends ViewComponent {\n\n    isPublic = true;\n\n    // Data is assigned straight, but could come from API\n    // ListState type is convinient for supporting .update\n    /** @type { ListState&lt;Array&gt; } */\n    rolesList = [\n        {\n            \"id\": 1,//First item unique id\n            \"title\": \"Vice President of Engineering\",\n            \"children\": [ {\n                \"title\": \"Engineering Manager\",\n                \"children\": [{\"title\": \"Senior Dev\"},{\"title\": \"Dev\"}]\n            }]\n        },\n        {\n            \"id\": 2,//Second item unique id\n            \"title\": \"Vice President of Marketing\",\n            \"children\": [ {\n                \"title\": \"Marketing Manager\",\n                \"children\": [ {\"title\": \"Marketing Specialist\"} ]\n            }]\n        }\n    ];\n\n    updateRole(){\n        const role = this.rolesList.value[0];\n        role.title = 'Senior VP of Eng';\n        role.children[0].children[0].title = 'Tech Lead';       \n        role.children[0].children[1].title = 'Senior Dev';      \n        this.rolesList.update([role]);\n    }\n\n}\n</code></pre> <p>When updating, we call the update method under the list, and we need to pass either the whoule list (updatet), or an array with every single update item.</p> <p>Deletion capability is also available, then, when it comes to @for loop item we have to specify an array with the different elements to remove. E.g. <code>this.rolesList.delete([2])</code> will remove the Vice President of Marketing.</p> <p>Result:</p> <p></p> <p></p>"},{"location":"template-logic/#top-level-conditional-using-ifendif-if","title":"Top Level conditional using @if/@endif (if)","text":"<p>Business Logic in the template allows us to used just any kind of JavaScript condition expression.</p> <p>Every single conditiona validation has it's own bloack, else statement is not provided.</p> <p>General consideration</p> <p>Except for the <code>@for</code> scenario, the content wrapped inside <code>@if</code> will be reactive according to the stated condition.</p> <p>Exceptional case - When wrapping @for into @if</p> <ol> <li> <p>Wrapping <code>@for</code> inside <code>@if</code> (like lines 17 to 27 in bellow example) makes it behave like <code>(renderIf)</code>: if the <code>@if</code> condition changes to true, the UI won\u2019t automatically update.</p> </li> <li> <p>If reactivity (hide/unhide) is needed for the <code>@for</code> content, the recommended way is to used the <code>(showIf)</code> directive.</p> </li> </ol> OrganizationHierarchy.jsOrganizationHierarchy.html Component<pre><code>import { ViewComponent } from \"../../@still/component/super/ViewComponent.js\";\nimport { ListState } from \"../../@still/component/type/ComponentType.js\";\nimport { organizationData } from \"./organization-data.js\";\n\nexport class OrganizationHierarchy extends ViewComponent {\n\n    isPublic = true;\n\n    // Data is coming from a js file, but could be API\n    // ListState type is convinient for better experience\n    /** @type { ListState&lt;Array&gt; } */\n    rolesList = organizationData;\n\n    userPermission = 'regular';\n\n    changePermission(){\n        if(this.userPermission.value === 'Admin')\n            this.userPermission = 'regular';\n        else\n            this.userPermission = 'Admin';\n    }\n\n}\n</code></pre> Template<pre><code>&lt;div style=\"padding: 20px;\"&gt;\n\n  @if(this.userPermission === 'Admin')\n    Full User Privileges\n  @endif\n\n  @if(this.userPermission !== 'Admin')\n    Limitted User Privileges\n  @endif\n\n  &lt;br&gt;\n  &lt;button (click)=\"changePermission()\"&gt;Change permission&lt;/button&gt;\n  &lt;br&gt;\n  @if(this.userPermission === 'Admin')\n    &lt;ul&gt;\n    @for(role in this.rolesList)\n      &lt;li&gt;\n        {role.title}\n          &lt;ul style=\"margin-left: 15px;\"&gt;\n          @for(subRole in role.children)\n            &lt;li&gt;{subRole.title}&lt;/li&gt;  \n          @endfor\n        &lt;/ul&gt;\n      &lt;/li&gt;\n    @endfor\n    &lt;/ul&gt;\n  @endif\n\n&lt;/div&gt;\n</code></pre> <p>In the above example, since the userPermission is set to regular, the list won't be presented, and title value will be according.</p> <p>Result:</p> <p></p> <p>If permission changes to admin at runtime, the title updates accordingly, but the tree does not, because it's generated from the loop, in this case <code>@if</code> behaves as <code>(renderIf)</code>.</p> <p></p>"},{"location":"template-logic/#using-showif-to-hide-for-content-and-keep-reactivity","title":"Using <code>(showIf)</code> to hide @for content and keep reactivity","text":"<p>The (showIf) directive works especially with flags, hence they (flags) need to be annotated with <code>@Prop</code> annotation.</p> <p>The directive is placed straight to our list tag (UL) thereby replacing the @if scope, but we could also use another outer container.</p> OrganizationHierarchy.htmlOrganizationHierarchy.js Template<pre><code>&lt;div style=\"padding: 20px;\"&gt;\n\n  @if(this.userPermission === 'Admin')\n    Full User Privileges\n  @endif\n\n  @if(this.userPermission !== 'Admin')\n    Limitted User Privileges\n  @endif\n\n  &lt;br&gt;\n  &lt;button (click)=\"changePermission()\"&gt;Change permission&lt;/button&gt;\n  &lt;br&gt;\n\n  &lt;ul (showIf)=\"self.hasPermission\"&gt;\n    @for(role in this.rolesList)\n      &lt;li&gt;\n      {role.title}\n        &lt;ul style=\"margin-left: 15px;\"&gt;\n          @for(subRole in role.children)\n            &lt;li&gt;{subRole.title}&lt;/li&gt;  \n          @endfor\n        &lt;/ul&gt;\n      &lt;/li&gt;\n    @endfor\n  &lt;/ul&gt;\n\n&lt;/div&gt;\n</code></pre> Component<pre><code>import { ViewComponent } from \"../../@still/component/super/ViewComponent.js\";\nimport { ListState } from \"../../@still/component/type/ComponentType.js\";\nimport { organizationData } from \"./organization-data.js\";\n\nexport class OrganizationHierarchy extends ViewComponent {\n\n    isPublic = true;\n\n    // Data is coming from a js file, but could be API\n    // ListState type is convinient for better experience\n    /** @type { ListState&lt;Array&gt; } */\n    rolesList = organizationData;\n\n    userPermission = 'regular';\n\n    // Flags in stilljs need to be annotated with @Prop\n    /** @Prop */\n    hasPermission = false;\n\n    changePermission(){\n        if(this.userPermission.value === 'Admin'){\n            this.userPermission = 'regular';\n            this.hasPermission = false;\n        } else {\n            this.userPermission = 'Admin';\n            this.hasPermission = true;\n        }\n    }\n\n}\n</code></pre> <p>Result:</p> <p></p> <p></p>"},{"location":"template-logic/#using-inline-expression-for-condition","title":"Using inline expression for condition:","text":"<p>Inline block is especially for conditional scenario, except for loops (for) it supports whole <code>if</code> statements block with as well as <code>else if</code> as needed.</p> OrganizationHierarchy.html Component<pre><code>&lt;div style=\"padding: 20px;\"&gt;\n\n${ this.userPermission === 'Admin' ? 'Full User Privileges' : 'Limitted User Privileges' }\n\n@if(this.userPermission === 'Admin')\n&lt;ul&gt;\n    @for(role in this.rolesList)\n    &lt;li&gt;\n        {role.title}\n        &lt;ul style=\"margin-left: 15px;\"&gt;\n        @for(subRole in role.children)\n            &lt;li&gt;{subRole.title}&lt;/li&gt;    \n        @endfor\n        &lt;/ul&gt;\n    &lt;/li&gt;\n    @endfor\n&lt;/ul&gt;\n@endif\n&lt;/div&gt;\n</code></pre> <p>The inline expression is also a good approach for conditional formating when outside the for loop.</p> <p></p>"},{"location":"template-logic/#to-conclude","title":"To conclude","text":"<p>Template logic in Still.js is a good alternative or complement to the template directives (line <code>(forEach)</code>, <code>(showIf)</code>, <code>(renderIf)</code>). </p> <p>Using nested @for loops and complex @if conditions allows handling complex scenarios within a single component, reducing the need for multiple embedded components and improving performance. </p>"},{"location":"typing-and-typ-hinting/","title":"TYPE & TYPE HINTING","text":""},{"location":"typing-and-typ-hinting/#typying-techniques-in-stilljs","title":"Typying techniques in Still.js","text":"<p>Work in Progress - Coming Soon</p> <p>We're still preparing and elaborating the content which will be part of this page, please just be a bit patient, It'll be here soon.</p> <p></p>"}]}